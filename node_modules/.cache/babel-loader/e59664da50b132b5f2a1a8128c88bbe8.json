{"ast":null,"code":"/**\r\n * DevExtreme (viz/range_selector/slider_marker.js)\r\n * Version: 19.2.7\r\n * Build date: Thu Mar 26 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar patchFontOptions = require(\"../core/utils\").patchFontOptions;\n\nvar SLIDER_MARKER_UPDATE_DELAY = 75;\n\nvar POINTER_SIZE = require(\"./common\").consts.pointerSize;\n\nfunction SliderMarker(renderer, root, isLeftPointer) {\n  var that = this;\n  that._isLeftPointer = isLeftPointer;\n  that._isOverlapped = false;\n  that._group = renderer.g().attr({\n    \"class\": \"slider-marker\"\n  }).append(root);\n  that._area = renderer.path(null, \"area\").append(that._group);\n  that._label = renderer.text().attr({\n    align: \"left\"\n  }).append(that._group);\n  that._tracker = renderer.rect().attr({\n    \"class\": \"slider-marker-tracker\",\n    fill: \"#000000\",\n    opacity: 1e-4\n  }).css({\n    cursor: \"pointer\"\n  }).append(that._group);\n  that._border = renderer.rect(0, 0, 1, 0);\n}\n\nSliderMarker.prototype = {\n  constructor: SliderMarker,\n  _getRectSize: function _getRectSize(textSize) {\n    return {\n      width: Math.round(2 * this._paddingLeftRight + textSize.width),\n      height: Math.round(2 * this._paddingTopBottom + textSize.height)\n    };\n  },\n  _getTextSize: function _getTextSize() {\n    var textSize = this._label.getBBox();\n\n    if (!this._textHeight && isFinite(textSize.height)) {\n      this._textHeight = textSize.height;\n    }\n\n    return {\n      width: textSize.width,\n      height: this._textHeight,\n      y: textSize.y\n    };\n  },\n  _getAreaPointsInfo: function _getAreaPointsInfo(textSize) {\n    var that = this;\n\n    var rectSize = that._getRectSize(textSize);\n\n    var rectWidth = rectSize.width;\n    var rectHeight = rectSize.height;\n    var rectLeftBorder = -rectWidth;\n    var rectRightBorder = 0;\n    var pointerRightPoint = POINTER_SIZE;\n    var pointerCenterPoint = 0;\n    var pointerLeftPoint = -POINTER_SIZE;\n    var position = that._position;\n    var isLeft = that._isLeftPointer;\n\n    var correctCloudBorders = function correctCloudBorders() {\n      rectLeftBorder++;\n      rectRightBorder++;\n      pointerRightPoint++;\n      pointerCenterPoint++;\n      pointerLeftPoint++;\n    };\n\n    var checkPointerBorders = function checkPointerBorders() {\n      if (pointerRightPoint > rectRightBorder) {\n        pointerRightPoint = rectRightBorder;\n      } else {\n        if (pointerLeftPoint < rectLeftBorder) {\n          pointerLeftPoint = rectLeftBorder;\n        }\n      }\n\n      isLeft && correctCloudBorders();\n    };\n\n    var borderPosition = position;\n\n    if (isLeft) {\n      if (position > that._range[1] - rectWidth) {\n        rectRightBorder = -position + that._range[1];\n        rectLeftBorder = rectRightBorder - rectWidth;\n        checkPointerBorders();\n        borderPosition += rectLeftBorder;\n      } else {\n        rectLeftBorder = pointerLeftPoint = 0;\n        rectRightBorder = rectWidth;\n      }\n    } else {\n      if (position - that._range[0] < rectWidth) {\n        rectLeftBorder = -(position - that._range[0]);\n        rectRightBorder = rectLeftBorder + rectWidth;\n        checkPointerBorders();\n        borderPosition += rectRightBorder;\n      } else {\n        pointerRightPoint = 0;\n        correctCloudBorders();\n      }\n    }\n\n    that._borderPosition = borderPosition;\n    return {\n      offset: rectLeftBorder,\n      isCut: (!isLeft || pointerCenterPoint !== pointerLeftPoint) && (isLeft || pointerCenterPoint !== pointerRightPoint),\n      points: [rectLeftBorder, 0, rectRightBorder, 0, rectRightBorder, rectHeight, pointerRightPoint, rectHeight, pointerCenterPoint, rectHeight + POINTER_SIZE, pointerLeftPoint, rectHeight, rectLeftBorder, rectHeight]\n    };\n  },\n  _update: function _update() {\n    var that = this;\n    var textSize;\n    var currentTextSize;\n    var rectSize;\n    clearTimeout(that._timeout);\n\n    that._label.attr({\n      text: that._text || \"\"\n    });\n\n    currentTextSize = that._getTextSize();\n    rectSize = that._getRectSize(currentTextSize);\n    textSize = that._textSize || currentTextSize;\n    textSize = that._textSize = currentTextSize.width > textSize.width || currentTextSize.height > textSize.height ? currentTextSize : textSize;\n    that._timeout = setTimeout(function () {\n      updateSliderMarker(currentTextSize, rectSize);\n      that._textSize = currentTextSize;\n    }, SLIDER_MARKER_UPDATE_DELAY);\n\n    function updateSliderMarker(size, rectSize) {\n      var points;\n      var pointsData;\n      var offset;\n      rectSize = rectSize || that._getRectSize(size);\n\n      that._group.attr({\n        translateY: -(rectSize.height + POINTER_SIZE)\n      });\n\n      pointsData = that._getAreaPointsInfo(size);\n      points = pointsData.points;\n      offset = pointsData.offset;\n\n      that._area.attr({\n        points: points\n      });\n\n      that._border.attr({\n        x: that._isLeftPointer ? points[0] - 1 : points[2],\n        height: pointsData.isCut ? rectSize.height : rectSize.height + POINTER_SIZE\n      });\n\n      that._tracker.attr({\n        translateX: offset,\n        width: rectSize.width,\n        height: rectSize.height + POINTER_SIZE\n      });\n\n      that._label.attr({\n        translateX: that._paddingLeftRight + offset,\n        translateY: rectSize.height / 2 - (size.y + size.height / 2)\n      });\n    }\n\n    updateSliderMarker(textSize);\n  },\n  setText: function setText(value) {\n    this._text = value;\n  },\n  setPosition: function setPosition(position) {\n    this._position = position;\n\n    this._update();\n  },\n  applyOptions: function applyOptions(options, screenRange) {\n    var that = this;\n    that._range = screenRange;\n    that._paddingLeftRight = options.paddingLeftRight;\n    that._paddingTopBottom = options.paddingTopBottom;\n    that._textHeight = null;\n    that._colors = [options.invalidRangeColor, options.color];\n\n    that._area.attr({\n      fill: options.color\n    });\n\n    that._border.attr({\n      fill: options.borderColor\n    });\n\n    that._label.css(patchFontOptions(options.font));\n\n    that._update();\n  },\n  getTracker: function getTracker() {\n    return this._tracker;\n  },\n  setValid: function setValid(isValid) {\n    this._area.attr({\n      fill: this._colors[Number(isValid)]\n    });\n  },\n  setColor: function setColor(color) {\n    this._area.attr({\n      fill: color\n    });\n  },\n  dispose: function dispose() {\n    clearTimeout(this._timeout);\n  },\n  setOverlapped: function setOverlapped(isOverlapped) {\n    var that = this;\n\n    if (that._isOverlapped !== isOverlapped) {\n      if (isOverlapped) {\n        that._border.append(that._group);\n      } else {\n        that._isOverlapped && that._border.remove();\n      }\n\n      that._isOverlapped = isOverlapped;\n    }\n  },\n  getBorderPosition: function getBorderPosition() {\n    return this._borderPosition;\n  }\n};\nmodule.exports = SliderMarker;","map":{"version":3,"sources":["C:/Users/va112/Documents/Webdev/React/Corona/node_modules/devextreme/viz/range_selector/slider_marker.js"],"names":["patchFontOptions","require","SLIDER_MARKER_UPDATE_DELAY","POINTER_SIZE","consts","pointerSize","SliderMarker","renderer","root","isLeftPointer","that","_isLeftPointer","_isOverlapped","_group","g","attr","append","_area","path","_label","text","align","_tracker","rect","fill","opacity","css","cursor","_border","prototype","constructor","_getRectSize","textSize","width","Math","round","_paddingLeftRight","height","_paddingTopBottom","_getTextSize","getBBox","_textHeight","isFinite","y","_getAreaPointsInfo","rectSize","rectWidth","rectHeight","rectLeftBorder","rectRightBorder","pointerRightPoint","pointerCenterPoint","pointerLeftPoint","position","_position","isLeft","correctCloudBorders","checkPointerBorders","borderPosition","_range","_borderPosition","offset","isCut","points","_update","currentTextSize","clearTimeout","_timeout","_text","_textSize","setTimeout","updateSliderMarker","size","pointsData","translateY","x","translateX","setText","value","setPosition","applyOptions","options","screenRange","paddingLeftRight","paddingTopBottom","_colors","invalidRangeColor","color","borderColor","font","getTracker","setValid","isValid","Number","setColor","dispose","setOverlapped","isOverlapped","remove","getBorderPosition","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * DevExtreme (viz/range_selector/slider_marker.js)\r\n * Version: 19.2.7\r\n * Build date: Thu Mar 26 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\"use strict\";\r\nvar patchFontOptions = require(\"../core/utils\").patchFontOptions;\r\nvar SLIDER_MARKER_UPDATE_DELAY = 75;\r\nvar POINTER_SIZE = require(\"./common\").consts.pointerSize;\r\n\r\nfunction SliderMarker(renderer, root, isLeftPointer) {\r\n    var that = this;\r\n    that._isLeftPointer = isLeftPointer;\r\n    that._isOverlapped = false;\r\n    that._group = renderer.g().attr({\r\n        \"class\": \"slider-marker\"\r\n    }).append(root);\r\n    that._area = renderer.path(null, \"area\").append(that._group);\r\n    that._label = renderer.text().attr({\r\n        align: \"left\"\r\n    }).append(that._group);\r\n    that._tracker = renderer.rect().attr({\r\n        \"class\": \"slider-marker-tracker\",\r\n        fill: \"#000000\",\r\n        opacity: 1e-4\r\n    }).css({\r\n        cursor: \"pointer\"\r\n    }).append(that._group);\r\n    that._border = renderer.rect(0, 0, 1, 0)\r\n}\r\nSliderMarker.prototype = {\r\n    constructor: SliderMarker,\r\n    _getRectSize: function(textSize) {\r\n        return {\r\n            width: Math.round(2 * this._paddingLeftRight + textSize.width),\r\n            height: Math.round(2 * this._paddingTopBottom + textSize.height)\r\n        }\r\n    },\r\n    _getTextSize: function() {\r\n        var textSize = this._label.getBBox();\r\n        if (!this._textHeight && isFinite(textSize.height)) {\r\n            this._textHeight = textSize.height\r\n        }\r\n        return {\r\n            width: textSize.width,\r\n            height: this._textHeight,\r\n            y: textSize.y\r\n        }\r\n    },\r\n    _getAreaPointsInfo: function(textSize) {\r\n        var that = this;\r\n        var rectSize = that._getRectSize(textSize);\r\n        var rectWidth = rectSize.width;\r\n        var rectHeight = rectSize.height;\r\n        var rectLeftBorder = -rectWidth;\r\n        var rectRightBorder = 0;\r\n        var pointerRightPoint = POINTER_SIZE;\r\n        var pointerCenterPoint = 0;\r\n        var pointerLeftPoint = -POINTER_SIZE;\r\n        var position = that._position;\r\n        var isLeft = that._isLeftPointer;\r\n        var correctCloudBorders = function() {\r\n            rectLeftBorder++;\r\n            rectRightBorder++;\r\n            pointerRightPoint++;\r\n            pointerCenterPoint++;\r\n            pointerLeftPoint++\r\n        };\r\n        var checkPointerBorders = function() {\r\n            if (pointerRightPoint > rectRightBorder) {\r\n                pointerRightPoint = rectRightBorder\r\n            } else {\r\n                if (pointerLeftPoint < rectLeftBorder) {\r\n                    pointerLeftPoint = rectLeftBorder\r\n                }\r\n            }\r\n            isLeft && correctCloudBorders()\r\n        };\r\n        var borderPosition = position;\r\n        if (isLeft) {\r\n            if (position > that._range[1] - rectWidth) {\r\n                rectRightBorder = -position + that._range[1];\r\n                rectLeftBorder = rectRightBorder - rectWidth;\r\n                checkPointerBorders();\r\n                borderPosition += rectLeftBorder\r\n            } else {\r\n                rectLeftBorder = pointerLeftPoint = 0;\r\n                rectRightBorder = rectWidth\r\n            }\r\n        } else {\r\n            if (position - that._range[0] < rectWidth) {\r\n                rectLeftBorder = -(position - that._range[0]);\r\n                rectRightBorder = rectLeftBorder + rectWidth;\r\n                checkPointerBorders();\r\n                borderPosition += rectRightBorder\r\n            } else {\r\n                pointerRightPoint = 0;\r\n                correctCloudBorders()\r\n            }\r\n        }\r\n        that._borderPosition = borderPosition;\r\n        return {\r\n            offset: rectLeftBorder,\r\n            isCut: (!isLeft || pointerCenterPoint !== pointerLeftPoint) && (isLeft || pointerCenterPoint !== pointerRightPoint),\r\n            points: [rectLeftBorder, 0, rectRightBorder, 0, rectRightBorder, rectHeight, pointerRightPoint, rectHeight, pointerCenterPoint, rectHeight + POINTER_SIZE, pointerLeftPoint, rectHeight, rectLeftBorder, rectHeight]\r\n        }\r\n    },\r\n    _update: function() {\r\n        var that = this;\r\n        var textSize;\r\n        var currentTextSize;\r\n        var rectSize;\r\n        clearTimeout(that._timeout);\r\n        that._label.attr({\r\n            text: that._text || \"\"\r\n        });\r\n        currentTextSize = that._getTextSize();\r\n        rectSize = that._getRectSize(currentTextSize);\r\n        textSize = that._textSize || currentTextSize;\r\n        textSize = that._textSize = currentTextSize.width > textSize.width || currentTextSize.height > textSize.height ? currentTextSize : textSize;\r\n        that._timeout = setTimeout(function() {\r\n            updateSliderMarker(currentTextSize, rectSize);\r\n            that._textSize = currentTextSize\r\n        }, SLIDER_MARKER_UPDATE_DELAY);\r\n\r\n        function updateSliderMarker(size, rectSize) {\r\n            var points;\r\n            var pointsData;\r\n            var offset;\r\n            rectSize = rectSize || that._getRectSize(size);\r\n            that._group.attr({\r\n                translateY: -(rectSize.height + POINTER_SIZE)\r\n            });\r\n            pointsData = that._getAreaPointsInfo(size);\r\n            points = pointsData.points;\r\n            offset = pointsData.offset;\r\n            that._area.attr({\r\n                points: points\r\n            });\r\n            that._border.attr({\r\n                x: that._isLeftPointer ? points[0] - 1 : points[2],\r\n                height: pointsData.isCut ? rectSize.height : rectSize.height + POINTER_SIZE\r\n            });\r\n            that._tracker.attr({\r\n                translateX: offset,\r\n                width: rectSize.width,\r\n                height: rectSize.height + POINTER_SIZE\r\n            });\r\n            that._label.attr({\r\n                translateX: that._paddingLeftRight + offset,\r\n                translateY: rectSize.height / 2 - (size.y + size.height / 2)\r\n            })\r\n        }\r\n        updateSliderMarker(textSize)\r\n    },\r\n    setText: function(value) {\r\n        this._text = value\r\n    },\r\n    setPosition: function(position) {\r\n        this._position = position;\r\n        this._update()\r\n    },\r\n    applyOptions: function(options, screenRange) {\r\n        var that = this;\r\n        that._range = screenRange;\r\n        that._paddingLeftRight = options.paddingLeftRight;\r\n        that._paddingTopBottom = options.paddingTopBottom;\r\n        that._textHeight = null;\r\n        that._colors = [options.invalidRangeColor, options.color];\r\n        that._area.attr({\r\n            fill: options.color\r\n        });\r\n        that._border.attr({\r\n            fill: options.borderColor\r\n        });\r\n        that._label.css(patchFontOptions(options.font));\r\n        that._update()\r\n    },\r\n    getTracker: function() {\r\n        return this._tracker\r\n    },\r\n    setValid: function(isValid) {\r\n        this._area.attr({\r\n            fill: this._colors[Number(isValid)]\r\n        })\r\n    },\r\n    setColor: function(color) {\r\n        this._area.attr({\r\n            fill: color\r\n        })\r\n    },\r\n    dispose: function() {\r\n        clearTimeout(this._timeout)\r\n    },\r\n    setOverlapped: function(isOverlapped) {\r\n        var that = this;\r\n        if (that._isOverlapped !== isOverlapped) {\r\n            if (isOverlapped) {\r\n                that._border.append(that._group)\r\n            } else {\r\n                that._isOverlapped && that._border.remove()\r\n            }\r\n            that._isOverlapped = isOverlapped\r\n        }\r\n    },\r\n    getBorderPosition: function() {\r\n        return this._borderPosition\r\n    }\r\n};\r\nmodule.exports = SliderMarker;\r\n"]},"metadata":{},"sourceType":"script"}