{"ast":null,"code":"/**\r\n * DevExtreme (viz/components/data_validator.js)\r\n * Version: 19.2.7\r\n * Build date: Thu Mar 26 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar typeUtils = require(\"../../core/utils/type\");\n\nvar STRING = \"string\";\nvar NUMERIC = \"numeric\";\nvar DATETIME = \"datetime\";\nvar DISCRETE = \"discrete\";\nvar SEMIDISCRETE = \"semidiscrete\";\nvar CONTINUOUS = \"continuous\";\nvar LOGARITHMIC = \"logarithmic\";\nvar VALUE_TYPE = \"valueType\";\nvar ARGUMENT_TYPE = \"argumentType\";\n\nvar extend = require(\"../../core/utils/extend\").extend;\n\nvar axisTypeParser = require(\"../core/utils\").enumParser([STRING, NUMERIC, DATETIME]);\n\nvar _getParser = require(\"./parse_utils\").getParser;\n\nvar _isDefined = typeUtils.isDefined;\nvar _isFunction = typeUtils.isFunction;\nvar _isArray = Array.isArray;\nvar _isString = typeUtils.isString;\nvar _isDate = typeUtils.isDate;\nvar _isNumber = typeUtils.isNumeric;\nvar _isObject = typeUtils.isObject;\n\nfunction groupingValues(data, others, valueField, index) {\n  if (index >= 0) {\n    data.slice(index).forEach(function (cell) {\n      if (_isDefined(cell[valueField])) {\n        others[valueField] += cell[valueField];\n        cell[valueField] = void 0;\n      }\n    });\n  }\n}\n\nfunction processGroups(groups) {\n  groups.forEach(function (group) {\n    group.valueType = group.valueAxisType = null;\n    group.series.forEach(function (series) {\n      series.updateDataType({});\n    });\n    group.valueAxis && group.valueAxis.resetTypes(VALUE_TYPE);\n  });\n}\n\nfunction sortValues(data, asc, selector) {\n  var func = asc ? function (a, b) {\n    return a - b;\n  } : function (a, b) {\n    return b - a;\n  };\n  data.sort(function (a, b) {\n    var valA = selector(a);\n    var valB = selector(b);\n    var aa = _isDefined(valA) ? 1 : 0;\n    var bb = _isDefined(valB) ? 1 : 0;\n    return aa && bb ? func(valA, valB) : func(aa, bb);\n  });\n  return data;\n}\n\nfunction resetArgumentAxes(axes) {\n  axes && axes.forEach(function (axis) {\n    axis.resetTypes(ARGUMENT_TYPE);\n  });\n}\n\nfunction parseCategories(categories, parser) {\n  var newArray = [];\n  categories.forEach(function (category) {\n    var parsedCategory = parser(category);\n    void 0 !== parsedCategory && newArray.push(parsedCategory);\n  });\n  return newArray;\n}\n\nfunction parseAxisCategories(groupsData, parsers) {\n  var argumentCategories = groupsData.argumentOptions && groupsData.argumentOptions.categories;\n  groupsData.groups.forEach(function (valueGroup, i) {\n    var categories = valueGroup.valueOptions && valueGroup.valueOptions.categories;\n\n    if (categories) {\n      valueGroup.valueOptions.categories = parseCategories(categories, parsers[i + 1]);\n    }\n  });\n\n  if (argumentCategories) {\n    groupsData.argumentOptions.categories = parseCategories(argumentCategories, parsers[0]);\n  }\n}\n\nfunction eigen(x) {\n  return x;\n}\n\nfunction getType(unit, type) {\n  var result = type;\n\n  if (type === STRING || _isString(unit)) {\n    result = STRING;\n  } else {\n    if (type === DATETIME || _isDate(unit)) {\n      result = DATETIME;\n    } else {\n      if (_isNumber(unit)) {\n        result = NUMERIC;\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction correctAxisType(type, axisType, hasCategories, incidentOccurred) {\n  if (type === STRING && (axisType === CONTINUOUS || axisType === LOGARITHMIC || axisType === SEMIDISCRETE)) {\n    incidentOccurred(\"E2002\");\n  }\n\n  return axisType === LOGARITHMIC ? LOGARITHMIC : hasCategories || axisType === DISCRETE || type === STRING ? DISCRETE : axisType === SEMIDISCRETE ? SEMIDISCRETE : CONTINUOUS;\n}\n\nfunction validUnit(unit, field, incidentOccurred) {\n  if (unit) {\n    incidentOccurred(!_isNumber(unit) && !_isDate(unit) && !_isString(unit) ? \"E2003\" : \"E2004\", [field]);\n  }\n}\n\nfunction createParserUnit(type, axisType, incidentOccurred) {\n  var parser = type ? _getParser(type) : eigen;\n  var filterInfinity = axisType !== DISCRETE ? function (x) {\n    return isFinite(x) || void 0 === x ? x : null;\n  } : eigen;\n  return function (unit, field) {\n    var parseUnit = filterInfinity(parser(unit));\n\n    if (void 0 === parseUnit) {\n      validUnit(unit, field, incidentOccurred);\n    }\n\n    return parseUnit;\n  };\n}\n\nfunction prepareParsers(groupsData, incidentOccurred) {\n  var argumentParser = createParserUnit(groupsData.argumentType, groupsData.argumentAxisType, incidentOccurred);\n  var sizeParser;\n  var valueParser;\n  var categoryParsers = [argumentParser];\n  var cache = {};\n  var list = [];\n  groupsData.groups.forEach(function (group, groupIndex) {\n    group.series.forEach(function (series) {\n      valueParser = createParserUnit(group.valueType, group.valueAxisType, incidentOccurred);\n      sizeParser = createParserUnit(NUMERIC, CONTINUOUS, incidentOccurred);\n      cache[series.getArgumentField()] = argumentParser;\n      series.getValueFields().forEach(function (field) {\n        categoryParsers[groupIndex + 1] = valueParser;\n        cache[field] = valueParser;\n      });\n\n      if (series.getSizeField()) {\n        cache[series.getSizeField()] = sizeParser;\n      }\n    });\n  });\n\n  for (var field in cache) {\n    list.push([field, cache[field]]);\n  }\n\n  list.length && parseAxisCategories(groupsData, categoryParsers);\n  return list;\n}\n\nfunction getParsedCell(cell, parsers) {\n  var i;\n  var ii = parsers.length;\n  var obj = extend({}, cell);\n  var field;\n  var value;\n\n  for (i = 0; i < ii; ++i) {\n    field = parsers[i][0];\n    value = cell[field];\n    obj[field] = parsers[i][1](value, field);\n  }\n\n  return obj;\n}\n\nfunction parse(data, parsers) {\n  var parsedData = [];\n  var i;\n  var ii = data.length;\n  parsedData.length = ii;\n\n  for (i = 0; i < ii; ++i) {\n    parsedData[i] = getParsedCell(data[i], parsers);\n  }\n\n  return parsedData;\n}\n\nfunction findIndexByThreshold(data, valueField, threshold) {\n  var i;\n  var ii = data.length;\n  var value;\n\n  for (i = 0; i < ii; ++i) {\n    value = data[i][valueField];\n\n    if (_isDefined(value) && threshold > value) {\n      break;\n    }\n  }\n\n  return i;\n}\n\nfunction groupMinSlices(originalData, argumentField, valueField, smallValuesGrouping) {\n  smallValuesGrouping = smallValuesGrouping || {};\n  var mode = smallValuesGrouping.mode;\n  var others = {};\n  var data;\n\n  if (!mode || \"none\" === mode) {\n    return;\n  }\n\n  others[argumentField] = String(smallValuesGrouping.groupName || \"others\");\n  others[valueField] = 0;\n  data = sortValues(originalData.slice(), false, function (a) {\n    return a[valueField];\n  });\n  groupingValues(data, others, valueField, \"smallValueThreshold\" === mode ? findIndexByThreshold(data, valueField, smallValuesGrouping.threshold) : smallValuesGrouping.topCount);\n  others[valueField] && originalData.push(others);\n}\n\nfunction groupPieData(data, groupsData) {\n  var firstSeries = groupsData.groups[0] && groupsData.groups[0].series[0];\n  var isPie = firstSeries && (\"pie\" === firstSeries.type || \"doughnut\" === firstSeries.type || \"donut\" === firstSeries.type);\n\n  if (!isPie) {\n    return;\n  }\n\n  groupsData.groups.forEach(function (group) {\n    group.series.forEach(function (series) {\n      groupMinSlices(data, series.getArgumentField(), series.getValueFields()[0], series.getOptions().smallValuesGrouping);\n    });\n  });\n}\n\nfunction addUniqueItemToCollection(item, collection, itemsHash) {\n  if (!itemsHash[item]) {\n    collection.push(item);\n    itemsHash[item] = true;\n  }\n}\n\nfunction getUniqueArgumentFields(groupsData) {\n  var uniqueArgumentFields = [];\n  var hash = {};\n  groupsData.groups.forEach(function (group) {\n    group.series.forEach(function (series) {\n      addUniqueItemToCollection(series.getArgumentField(), uniqueArgumentFields, hash);\n    });\n  });\n  return uniqueArgumentFields;\n}\n\nfunction sort(a, b) {\n  var result = a - b;\n\n  if (isNaN(result)) {\n    if (!_isDefined(a)) {\n      return 1;\n    }\n\n    if (!_isDefined(b)) {\n      return -1;\n    }\n\n    return 0;\n  }\n\n  return result;\n}\n\nfunction sortByArgument(data, argumentField) {\n  return data.slice().sort(function (a, b) {\n    return sort(a[argumentField], b[argumentField]);\n  });\n}\n\nfunction sortByCallback(data, callback) {\n  return data.slice().sort(callback);\n}\n\nfunction checkValueTypeOfGroup(group, cell) {\n  group.series.forEach(function (series) {\n    series.getValueFields().forEach(function (field) {\n      group.valueType = getType(cell[field], group.valueType);\n    });\n  });\n  return group.valueType;\n}\n\nfunction getSortByCategories(categories) {\n  var hash = {};\n  categories.forEach(function (value, i) {\n    hash[value] = i;\n  });\n  return function (data, argumentField) {\n    return sortValues(data.slice(), true, function (a) {\n      return hash[a[argumentField]];\n    });\n  };\n}\n\nfunction sortData(data, groupsData, options, uniqueArgumentFields) {\n  var dataByArguments = {};\n  var isDiscrete = groupsData.argumentAxisType === DISCRETE;\n  var userCategories = isDiscrete && groupsData.argumentOptions && groupsData.argumentOptions.categories;\n\n  var sortFunction = function sortFunction(data) {\n    return data;\n  };\n\n  var sortingMethodOption = options.sortingMethod;\n  var reSortCategories;\n\n  if (!userCategories && _isFunction(sortingMethodOption)) {\n    data = sortByCallback(data, sortingMethodOption);\n  }\n\n  if (isDiscrete) {\n    groupsData.categories = getCategories(data, uniqueArgumentFields, userCategories);\n  }\n\n  if (userCategories || !_isFunction(sortingMethodOption) && groupsData.argumentType === STRING && !options._skipArgumentSorting) {\n    sortFunction = getSortByCategories(groupsData.categories);\n  } else {\n    if (true === sortingMethodOption && groupsData.argumentType !== STRING) {\n      sortFunction = sortByArgument;\n      reSortCategories = isDiscrete;\n    }\n  }\n\n  uniqueArgumentFields.forEach(function (field) {\n    dataByArguments[field] = sortFunction(data, field);\n  });\n\n  if (reSortCategories) {\n    groupsData.categories = groupsData.categories.sort(sort);\n  }\n\n  return dataByArguments;\n}\n\nfunction checkItemExistence(collection, item) {\n  return collection.map(function (collectionItem) {\n    return collectionItem.valueOf();\n  }).indexOf(item.valueOf()) === -1;\n}\n\nfunction getCategories(data, uniqueArgumentFields, userCategories) {\n  var categories = userCategories ? userCategories.slice() : [];\n  uniqueArgumentFields.forEach(function (field) {\n    data.forEach(function (item) {\n      var dataItem = item[field];\n      _isDefined(dataItem) && checkItemExistence(categories, dataItem) && categories.push(dataItem);\n    });\n  });\n  return categories;\n}\n\nfunction checkArgumentTypeOfGroup(series, cell, groupsData) {\n  series.forEach(function (currentSeries) {\n    groupsData.argumentType = getType(cell[currentSeries.getArgumentField()], groupsData.argumentType);\n  });\n  return groupsData.argumentType;\n}\n\nfunction checkType(data, groupsData, checkTypeForAllData) {\n  var groupsWithUndefinedValueType = [];\n  var groupsWithUndefinedArgumentType = [];\n  var argumentTypeGroup = groupsData.argumentOptions && axisTypeParser(groupsData.argumentOptions.argumentType);\n  var groupsIndexes;\n  groupsData.groups.forEach(function (group) {\n    if (!group.series.length) {\n      return;\n    }\n\n    var valueTypeGroup = group.valueOptions && axisTypeParser(group.valueOptions.valueType);\n    group.valueType = valueTypeGroup;\n    groupsData.argumentType = argumentTypeGroup;\n    !valueTypeGroup && groupsWithUndefinedValueType.push(group);\n    !argumentTypeGroup && groupsWithUndefinedArgumentType.push(group);\n  });\n\n  if (groupsWithUndefinedValueType.length || groupsWithUndefinedArgumentType.length) {\n    groupsIndexes = groupsWithUndefinedValueType.map(function (_, index) {\n      return index;\n    });\n    data.some(function (cell) {\n      var defineArg;\n      groupsWithUndefinedValueType.forEach(function (group, groupIndex) {\n        if (checkValueTypeOfGroup(group, cell) && groupsIndexes.indexOf(groupIndex) >= 0) {\n          groupsIndexes.splice(groupIndex, 1);\n        }\n      });\n\n      if (!defineArg) {\n        groupsWithUndefinedArgumentType.forEach(function (group) {\n          defineArg = checkArgumentTypeOfGroup(group.series, cell, groupsData);\n        });\n      }\n\n      if (!checkTypeForAllData && defineArg && 0 === groupsIndexes.length) {\n        return true;\n      }\n    });\n  }\n}\n\nfunction checkAxisType(groupsData, incidentOccurred) {\n  var argumentOptions = groupsData.argumentOptions || {};\n  var userArgumentCategories = argumentOptions && argumentOptions.categories || [];\n  var argumentAxisType = correctAxisType(groupsData.argumentType, argumentOptions.type, !!userArgumentCategories.length, incidentOccurred);\n  groupsData.groups.forEach(function (group) {\n    var valueOptions = group.valueOptions || {};\n    var valueCategories = valueOptions.categories || [];\n    var valueAxisType = correctAxisType(group.valueType, valueOptions.type, !!valueCategories.length, incidentOccurred);\n    group.series.forEach(function (series) {\n      var optionsSeries = {};\n      optionsSeries.argumentAxisType = argumentAxisType;\n      optionsSeries.valueAxisType = valueAxisType;\n      groupsData.argumentAxisType = groupsData.argumentAxisType || optionsSeries.argumentAxisType;\n      group.valueAxisType = group.valueAxisType || optionsSeries.valueAxisType;\n      optionsSeries.argumentType = groupsData.argumentType;\n      optionsSeries.valueType = group.valueType;\n      optionsSeries.showZero = valueOptions.showZero;\n      series.updateDataType(optionsSeries);\n    });\n    group.valueAxisType = group.valueAxisType || valueAxisType;\n\n    if (group.valueAxis) {\n      group.valueAxis.setTypes(group.valueAxisType, group.valueType, VALUE_TYPE);\n      group.valueAxis.validate();\n    }\n  });\n  groupsData.argumentAxisType = groupsData.argumentAxisType || argumentAxisType;\n\n  if (groupsData.argumentAxes) {\n    groupsData.argumentAxes.forEach(function (axis) {\n      axis.setTypes(groupsData.argumentAxisType, groupsData.argumentType, ARGUMENT_TYPE);\n      axis.validate();\n    });\n  }\n}\n\nfunction verifyData(source, incidentOccurred) {\n  var data = [];\n\n  var sourceIsDefined = _isDefined(source);\n\n  var hasError = sourceIsDefined && !_isArray(source);\n  var i;\n  var ii;\n  var k;\n  var item;\n\n  if (sourceIsDefined && !hasError) {\n    for (i = 0, ii = source.length, k = 0; i < ii; ++i) {\n      item = source[i];\n\n      if (_isObject(item)) {\n        data[k++] = item;\n      } else {\n        if (item) {\n          hasError = true;\n        }\n      }\n    }\n  }\n\n  if (hasError) {\n    incidentOccurred(\"E2001\");\n  }\n\n  return data;\n}\n\nfunction validateData(data, groupsData, incidentOccurred, options) {\n  var dataByArgumentFields;\n  data = verifyData(data, incidentOccurred);\n  groupsData.argumentType = groupsData.argumentAxisType = null;\n  processGroups(groupsData.groups);\n  resetArgumentAxes(groupsData.argumentAxes);\n  checkType(data, groupsData, options.checkTypeForAllData);\n  checkAxisType(groupsData, incidentOccurred);\n\n  if (options.convertToAxisDataType) {\n    data = parse(data, prepareParsers(groupsData, incidentOccurred));\n  }\n\n  groupPieData(data, groupsData);\n  dataByArgumentFields = sortData(data, groupsData, options, getUniqueArgumentFields(groupsData));\n  return dataByArgumentFields;\n}\n\nexports.validateData = validateData;","map":{"version":3,"sources":["C:/Users/va112/Documents/Webdev/React/Corona/node_modules/devextreme/viz/components/data_validator.js"],"names":["typeUtils","require","STRING","NUMERIC","DATETIME","DISCRETE","SEMIDISCRETE","CONTINUOUS","LOGARITHMIC","VALUE_TYPE","ARGUMENT_TYPE","extend","axisTypeParser","enumParser","_getParser","getParser","_isDefined","isDefined","_isFunction","isFunction","_isArray","Array","isArray","_isString","isString","_isDate","isDate","_isNumber","isNumeric","_isObject","isObject","groupingValues","data","others","valueField","index","slice","forEach","cell","processGroups","groups","group","valueType","valueAxisType","series","updateDataType","valueAxis","resetTypes","sortValues","asc","selector","func","a","b","sort","valA","valB","aa","bb","resetArgumentAxes","axes","axis","parseCategories","categories","parser","newArray","category","parsedCategory","push","parseAxisCategories","groupsData","parsers","argumentCategories","argumentOptions","valueGroup","i","valueOptions","eigen","x","getType","unit","type","result","correctAxisType","axisType","hasCategories","incidentOccurred","validUnit","field","createParserUnit","filterInfinity","isFinite","parseUnit","prepareParsers","argumentParser","argumentType","argumentAxisType","sizeParser","valueParser","categoryParsers","cache","list","groupIndex","getArgumentField","getValueFields","getSizeField","length","getParsedCell","ii","obj","value","parse","parsedData","findIndexByThreshold","threshold","groupMinSlices","originalData","argumentField","smallValuesGrouping","mode","String","groupName","topCount","groupPieData","firstSeries","isPie","getOptions","addUniqueItemToCollection","item","collection","itemsHash","getUniqueArgumentFields","uniqueArgumentFields","hash","isNaN","sortByArgument","sortByCallback","callback","checkValueTypeOfGroup","getSortByCategories","sortData","options","dataByArguments","isDiscrete","userCategories","sortFunction","sortingMethodOption","sortingMethod","reSortCategories","getCategories","_skipArgumentSorting","checkItemExistence","map","collectionItem","valueOf","indexOf","dataItem","checkArgumentTypeOfGroup","currentSeries","checkType","checkTypeForAllData","groupsWithUndefinedValueType","groupsWithUndefinedArgumentType","argumentTypeGroup","groupsIndexes","valueTypeGroup","_","some","defineArg","splice","checkAxisType","userArgumentCategories","valueCategories","optionsSeries","showZero","setTypes","validate","argumentAxes","verifyData","source","sourceIsDefined","hasError","k","validateData","dataByArgumentFields","convertToAxisDataType","exports"],"mappings":"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","sourcesContent":["/**\r\n * DevExtreme (viz/components/data_validator.js)\r\n * Version: 19.2.7\r\n * Build date: Thu Mar 26 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\"use strict\";\r\nvar typeUtils = require(\"../../core/utils/type\");\r\nvar STRING = \"string\";\r\nvar NUMERIC = \"numeric\";\r\nvar DATETIME = \"datetime\";\r\nvar DISCRETE = \"discrete\";\r\nvar SEMIDISCRETE = \"semidiscrete\";\r\nvar CONTINUOUS = \"continuous\";\r\nvar LOGARITHMIC = \"logarithmic\";\r\nvar VALUE_TYPE = \"valueType\";\r\nvar ARGUMENT_TYPE = \"argumentType\";\r\nvar extend = require(\"../../core/utils/extend\").extend;\r\nvar axisTypeParser = require(\"../core/utils\").enumParser([STRING, NUMERIC, DATETIME]);\r\nvar _getParser = require(\"./parse_utils\").getParser;\r\nvar _isDefined = typeUtils.isDefined;\r\nvar _isFunction = typeUtils.isFunction;\r\nvar _isArray = Array.isArray;\r\nvar _isString = typeUtils.isString;\r\nvar _isDate = typeUtils.isDate;\r\nvar _isNumber = typeUtils.isNumeric;\r\nvar _isObject = typeUtils.isObject;\r\n\r\nfunction groupingValues(data, others, valueField, index) {\r\n    if (index >= 0) {\r\n        data.slice(index).forEach(function(cell) {\r\n            if (_isDefined(cell[valueField])) {\r\n                others[valueField] += cell[valueField];\r\n                cell[valueField] = void 0\r\n            }\r\n        })\r\n    }\r\n}\r\n\r\nfunction processGroups(groups) {\r\n    groups.forEach(function(group) {\r\n        group.valueType = group.valueAxisType = null;\r\n        group.series.forEach(function(series) {\r\n            series.updateDataType({})\r\n        });\r\n        group.valueAxis && group.valueAxis.resetTypes(VALUE_TYPE)\r\n    })\r\n}\r\n\r\nfunction sortValues(data, asc, selector) {\r\n    var func = asc ? function(a, b) {\r\n        return a - b\r\n    } : function(a, b) {\r\n        return b - a\r\n    };\r\n    data.sort(function(a, b) {\r\n        var valA = selector(a);\r\n        var valB = selector(b);\r\n        var aa = _isDefined(valA) ? 1 : 0;\r\n        var bb = _isDefined(valB) ? 1 : 0;\r\n        return aa && bb ? func(valA, valB) : func(aa, bb)\r\n    });\r\n    return data\r\n}\r\n\r\nfunction resetArgumentAxes(axes) {\r\n    axes && axes.forEach(function(axis) {\r\n        axis.resetTypes(ARGUMENT_TYPE)\r\n    })\r\n}\r\n\r\nfunction parseCategories(categories, parser) {\r\n    var newArray = [];\r\n    categories.forEach(function(category) {\r\n        var parsedCategory = parser(category);\r\n        void 0 !== parsedCategory && newArray.push(parsedCategory)\r\n    });\r\n    return newArray\r\n}\r\n\r\nfunction parseAxisCategories(groupsData, parsers) {\r\n    var argumentCategories = groupsData.argumentOptions && groupsData.argumentOptions.categories;\r\n    groupsData.groups.forEach(function(valueGroup, i) {\r\n        var categories = valueGroup.valueOptions && valueGroup.valueOptions.categories;\r\n        if (categories) {\r\n            valueGroup.valueOptions.categories = parseCategories(categories, parsers[i + 1])\r\n        }\r\n    });\r\n    if (argumentCategories) {\r\n        groupsData.argumentOptions.categories = parseCategories(argumentCategories, parsers[0])\r\n    }\r\n}\r\n\r\nfunction eigen(x) {\r\n    return x\r\n}\r\n\r\nfunction getType(unit, type) {\r\n    var result = type;\r\n    if (type === STRING || _isString(unit)) {\r\n        result = STRING\r\n    } else {\r\n        if (type === DATETIME || _isDate(unit)) {\r\n            result = DATETIME\r\n        } else {\r\n            if (_isNumber(unit)) {\r\n                result = NUMERIC\r\n            }\r\n        }\r\n    }\r\n    return result\r\n}\r\n\r\nfunction correctAxisType(type, axisType, hasCategories, incidentOccurred) {\r\n    if (type === STRING && (axisType === CONTINUOUS || axisType === LOGARITHMIC || axisType === SEMIDISCRETE)) {\r\n        incidentOccurred(\"E2002\")\r\n    }\r\n    return axisType === LOGARITHMIC ? LOGARITHMIC : hasCategories || axisType === DISCRETE || type === STRING ? DISCRETE : axisType === SEMIDISCRETE ? SEMIDISCRETE : CONTINUOUS\r\n}\r\n\r\nfunction validUnit(unit, field, incidentOccurred) {\r\n    if (unit) {\r\n        incidentOccurred(!_isNumber(unit) && !_isDate(unit) && !_isString(unit) ? \"E2003\" : \"E2004\", [field])\r\n    }\r\n}\r\n\r\nfunction createParserUnit(type, axisType, incidentOccurred) {\r\n    var parser = type ? _getParser(type) : eigen;\r\n    var filterInfinity = axisType !== DISCRETE ? function(x) {\r\n        return isFinite(x) || void 0 === x ? x : null\r\n    } : eigen;\r\n    return function(unit, field) {\r\n        var parseUnit = filterInfinity(parser(unit));\r\n        if (void 0 === parseUnit) {\r\n            validUnit(unit, field, incidentOccurred)\r\n        }\r\n        return parseUnit\r\n    }\r\n}\r\n\r\nfunction prepareParsers(groupsData, incidentOccurred) {\r\n    var argumentParser = createParserUnit(groupsData.argumentType, groupsData.argumentAxisType, incidentOccurred);\r\n    var sizeParser;\r\n    var valueParser;\r\n    var categoryParsers = [argumentParser];\r\n    var cache = {};\r\n    var list = [];\r\n    groupsData.groups.forEach(function(group, groupIndex) {\r\n        group.series.forEach(function(series) {\r\n            valueParser = createParserUnit(group.valueType, group.valueAxisType, incidentOccurred);\r\n            sizeParser = createParserUnit(NUMERIC, CONTINUOUS, incidentOccurred);\r\n            cache[series.getArgumentField()] = argumentParser;\r\n            series.getValueFields().forEach(function(field) {\r\n                categoryParsers[groupIndex + 1] = valueParser;\r\n                cache[field] = valueParser\r\n            });\r\n            if (series.getSizeField()) {\r\n                cache[series.getSizeField()] = sizeParser\r\n            }\r\n        })\r\n    });\r\n    for (var field in cache) {\r\n        list.push([field, cache[field]])\r\n    }\r\n    list.length && parseAxisCategories(groupsData, categoryParsers);\r\n    return list\r\n}\r\n\r\nfunction getParsedCell(cell, parsers) {\r\n    var i;\r\n    var ii = parsers.length;\r\n    var obj = extend({}, cell);\r\n    var field;\r\n    var value;\r\n    for (i = 0; i < ii; ++i) {\r\n        field = parsers[i][0];\r\n        value = cell[field];\r\n        obj[field] = parsers[i][1](value, field)\r\n    }\r\n    return obj\r\n}\r\n\r\nfunction parse(data, parsers) {\r\n    var parsedData = [];\r\n    var i;\r\n    var ii = data.length;\r\n    parsedData.length = ii;\r\n    for (i = 0; i < ii; ++i) {\r\n        parsedData[i] = getParsedCell(data[i], parsers)\r\n    }\r\n    return parsedData\r\n}\r\n\r\nfunction findIndexByThreshold(data, valueField, threshold) {\r\n    var i;\r\n    var ii = data.length;\r\n    var value;\r\n    for (i = 0; i < ii; ++i) {\r\n        value = data[i][valueField];\r\n        if (_isDefined(value) && threshold > value) {\r\n            break\r\n        }\r\n    }\r\n    return i\r\n}\r\n\r\nfunction groupMinSlices(originalData, argumentField, valueField, smallValuesGrouping) {\r\n    smallValuesGrouping = smallValuesGrouping || {};\r\n    var mode = smallValuesGrouping.mode;\r\n    var others = {};\r\n    var data;\r\n    if (!mode || \"none\" === mode) {\r\n        return\r\n    }\r\n    others[argumentField] = String(smallValuesGrouping.groupName || \"others\");\r\n    others[valueField] = 0;\r\n    data = sortValues(originalData.slice(), false, function(a) {\r\n        return a[valueField]\r\n    });\r\n    groupingValues(data, others, valueField, \"smallValueThreshold\" === mode ? findIndexByThreshold(data, valueField, smallValuesGrouping.threshold) : smallValuesGrouping.topCount);\r\n    others[valueField] && originalData.push(others)\r\n}\r\n\r\nfunction groupPieData(data, groupsData) {\r\n    var firstSeries = groupsData.groups[0] && groupsData.groups[0].series[0];\r\n    var isPie = firstSeries && (\"pie\" === firstSeries.type || \"doughnut\" === firstSeries.type || \"donut\" === firstSeries.type);\r\n    if (!isPie) {\r\n        return\r\n    }\r\n    groupsData.groups.forEach(function(group) {\r\n        group.series.forEach(function(series) {\r\n            groupMinSlices(data, series.getArgumentField(), series.getValueFields()[0], series.getOptions().smallValuesGrouping)\r\n        })\r\n    })\r\n}\r\n\r\nfunction addUniqueItemToCollection(item, collection, itemsHash) {\r\n    if (!itemsHash[item]) {\r\n        collection.push(item);\r\n        itemsHash[item] = true\r\n    }\r\n}\r\n\r\nfunction getUniqueArgumentFields(groupsData) {\r\n    var uniqueArgumentFields = [];\r\n    var hash = {};\r\n    groupsData.groups.forEach(function(group) {\r\n        group.series.forEach(function(series) {\r\n            addUniqueItemToCollection(series.getArgumentField(), uniqueArgumentFields, hash)\r\n        })\r\n    });\r\n    return uniqueArgumentFields\r\n}\r\n\r\nfunction sort(a, b) {\r\n    var result = a - b;\r\n    if (isNaN(result)) {\r\n        if (!_isDefined(a)) {\r\n            return 1\r\n        }\r\n        if (!_isDefined(b)) {\r\n            return -1\r\n        }\r\n        return 0\r\n    }\r\n    return result\r\n}\r\n\r\nfunction sortByArgument(data, argumentField) {\r\n    return data.slice().sort(function(a, b) {\r\n        return sort(a[argumentField], b[argumentField])\r\n    })\r\n}\r\n\r\nfunction sortByCallback(data, callback) {\r\n    return data.slice().sort(callback)\r\n}\r\n\r\nfunction checkValueTypeOfGroup(group, cell) {\r\n    group.series.forEach(function(series) {\r\n        series.getValueFields().forEach(function(field) {\r\n            group.valueType = getType(cell[field], group.valueType)\r\n        })\r\n    });\r\n    return group.valueType\r\n}\r\n\r\nfunction getSortByCategories(categories) {\r\n    var hash = {};\r\n    categories.forEach(function(value, i) {\r\n        hash[value] = i\r\n    });\r\n    return function(data, argumentField) {\r\n        return sortValues(data.slice(), true, function(a) {\r\n            return hash[a[argumentField]]\r\n        })\r\n    }\r\n}\r\n\r\nfunction sortData(data, groupsData, options, uniqueArgumentFields) {\r\n    var dataByArguments = {};\r\n    var isDiscrete = groupsData.argumentAxisType === DISCRETE;\r\n    var userCategories = isDiscrete && groupsData.argumentOptions && groupsData.argumentOptions.categories;\r\n    var sortFunction = function(data) {\r\n        return data\r\n    };\r\n    var sortingMethodOption = options.sortingMethod;\r\n    var reSortCategories;\r\n    if (!userCategories && _isFunction(sortingMethodOption)) {\r\n        data = sortByCallback(data, sortingMethodOption)\r\n    }\r\n    if (isDiscrete) {\r\n        groupsData.categories = getCategories(data, uniqueArgumentFields, userCategories)\r\n    }\r\n    if (userCategories || !_isFunction(sortingMethodOption) && groupsData.argumentType === STRING && !options._skipArgumentSorting) {\r\n        sortFunction = getSortByCategories(groupsData.categories)\r\n    } else {\r\n        if (true === sortingMethodOption && groupsData.argumentType !== STRING) {\r\n            sortFunction = sortByArgument;\r\n            reSortCategories = isDiscrete\r\n        }\r\n    }\r\n    uniqueArgumentFields.forEach(function(field) {\r\n        dataByArguments[field] = sortFunction(data, field)\r\n    });\r\n    if (reSortCategories) {\r\n        groupsData.categories = groupsData.categories.sort(sort)\r\n    }\r\n    return dataByArguments\r\n}\r\n\r\nfunction checkItemExistence(collection, item) {\r\n    return collection.map(function(collectionItem) {\r\n        return collectionItem.valueOf()\r\n    }).indexOf(item.valueOf()) === -1\r\n}\r\n\r\nfunction getCategories(data, uniqueArgumentFields, userCategories) {\r\n    var categories = userCategories ? userCategories.slice() : [];\r\n    uniqueArgumentFields.forEach(function(field) {\r\n        data.forEach(function(item) {\r\n            var dataItem = item[field];\r\n            _isDefined(dataItem) && checkItemExistence(categories, dataItem) && categories.push(dataItem)\r\n        })\r\n    });\r\n    return categories\r\n}\r\n\r\nfunction checkArgumentTypeOfGroup(series, cell, groupsData) {\r\n    series.forEach(function(currentSeries) {\r\n        groupsData.argumentType = getType(cell[currentSeries.getArgumentField()], groupsData.argumentType)\r\n    });\r\n    return groupsData.argumentType\r\n}\r\n\r\nfunction checkType(data, groupsData, checkTypeForAllData) {\r\n    var groupsWithUndefinedValueType = [];\r\n    var groupsWithUndefinedArgumentType = [];\r\n    var argumentTypeGroup = groupsData.argumentOptions && axisTypeParser(groupsData.argumentOptions.argumentType);\r\n    var groupsIndexes;\r\n    groupsData.groups.forEach(function(group) {\r\n        if (!group.series.length) {\r\n            return\r\n        }\r\n        var valueTypeGroup = group.valueOptions && axisTypeParser(group.valueOptions.valueType);\r\n        group.valueType = valueTypeGroup;\r\n        groupsData.argumentType = argumentTypeGroup;\r\n        !valueTypeGroup && groupsWithUndefinedValueType.push(group);\r\n        !argumentTypeGroup && groupsWithUndefinedArgumentType.push(group)\r\n    });\r\n    if (groupsWithUndefinedValueType.length || groupsWithUndefinedArgumentType.length) {\r\n        groupsIndexes = groupsWithUndefinedValueType.map(function(_, index) {\r\n            return index\r\n        });\r\n        data.some(function(cell) {\r\n            var defineArg;\r\n            groupsWithUndefinedValueType.forEach(function(group, groupIndex) {\r\n                if (checkValueTypeOfGroup(group, cell) && groupsIndexes.indexOf(groupIndex) >= 0) {\r\n                    groupsIndexes.splice(groupIndex, 1)\r\n                }\r\n            });\r\n            if (!defineArg) {\r\n                groupsWithUndefinedArgumentType.forEach(function(group) {\r\n                    defineArg = checkArgumentTypeOfGroup(group.series, cell, groupsData)\r\n                })\r\n            }\r\n            if (!checkTypeForAllData && defineArg && 0 === groupsIndexes.length) {\r\n                return true\r\n            }\r\n        })\r\n    }\r\n}\r\n\r\nfunction checkAxisType(groupsData, incidentOccurred) {\r\n    var argumentOptions = groupsData.argumentOptions || {};\r\n    var userArgumentCategories = argumentOptions && argumentOptions.categories || [];\r\n    var argumentAxisType = correctAxisType(groupsData.argumentType, argumentOptions.type, !!userArgumentCategories.length, incidentOccurred);\r\n    groupsData.groups.forEach(function(group) {\r\n        var valueOptions = group.valueOptions || {};\r\n        var valueCategories = valueOptions.categories || [];\r\n        var valueAxisType = correctAxisType(group.valueType, valueOptions.type, !!valueCategories.length, incidentOccurred);\r\n        group.series.forEach(function(series) {\r\n            var optionsSeries = {};\r\n            optionsSeries.argumentAxisType = argumentAxisType;\r\n            optionsSeries.valueAxisType = valueAxisType;\r\n            groupsData.argumentAxisType = groupsData.argumentAxisType || optionsSeries.argumentAxisType;\r\n            group.valueAxisType = group.valueAxisType || optionsSeries.valueAxisType;\r\n            optionsSeries.argumentType = groupsData.argumentType;\r\n            optionsSeries.valueType = group.valueType;\r\n            optionsSeries.showZero = valueOptions.showZero;\r\n            series.updateDataType(optionsSeries)\r\n        });\r\n        group.valueAxisType = group.valueAxisType || valueAxisType;\r\n        if (group.valueAxis) {\r\n            group.valueAxis.setTypes(group.valueAxisType, group.valueType, VALUE_TYPE);\r\n            group.valueAxis.validate()\r\n        }\r\n    });\r\n    groupsData.argumentAxisType = groupsData.argumentAxisType || argumentAxisType;\r\n    if (groupsData.argumentAxes) {\r\n        groupsData.argumentAxes.forEach(function(axis) {\r\n            axis.setTypes(groupsData.argumentAxisType, groupsData.argumentType, ARGUMENT_TYPE);\r\n            axis.validate()\r\n        })\r\n    }\r\n}\r\n\r\nfunction verifyData(source, incidentOccurred) {\r\n    var data = [];\r\n    var sourceIsDefined = _isDefined(source);\r\n    var hasError = sourceIsDefined && !_isArray(source);\r\n    var i;\r\n    var ii;\r\n    var k;\r\n    var item;\r\n    if (sourceIsDefined && !hasError) {\r\n        for (i = 0, ii = source.length, k = 0; i < ii; ++i) {\r\n            item = source[i];\r\n            if (_isObject(item)) {\r\n                data[k++] = item\r\n            } else {\r\n                if (item) {\r\n                    hasError = true\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (hasError) {\r\n        incidentOccurred(\"E2001\")\r\n    }\r\n    return data\r\n}\r\n\r\nfunction validateData(data, groupsData, incidentOccurred, options) {\r\n    var dataByArgumentFields;\r\n    data = verifyData(data, incidentOccurred);\r\n    groupsData.argumentType = groupsData.argumentAxisType = null;\r\n    processGroups(groupsData.groups);\r\n    resetArgumentAxes(groupsData.argumentAxes);\r\n    checkType(data, groupsData, options.checkTypeForAllData);\r\n    checkAxisType(groupsData, incidentOccurred);\r\n    if (options.convertToAxisDataType) {\r\n        data = parse(data, prepareParsers(groupsData, incidentOccurred))\r\n    }\r\n    groupPieData(data, groupsData);\r\n    dataByArgumentFields = sortData(data, groupsData, options, getUniqueArgumentFields(groupsData));\r\n    return dataByArgumentFields\r\n}\r\nexports.validateData = validateData;\r\n"]},"metadata":{},"sourceType":"script"}