{"ast":null,"code":"/**\r\n * DevExtreme (viz/series/area_series.js)\r\n * Version: 19.2.7\r\n * Build date: Thu Mar 26 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar objectUtils = require(\"../../core/utils/object\");\n\nvar extend = require(\"../../core/utils/extend\").extend;\n\nvar scatterSeries = require(\"./scatter_series\").chart;\n\nvar lineSeries = require(\"./line_series\");\n\nvar chartLineSeries = lineSeries.chart.line;\nvar polarLineSeries = lineSeries.polar.line;\n\nvar _map = require(\"../core/utils\").map;\n\nvar _extend = extend;\nvar calculateBezierPoints = lineSeries.chart.spline._calculateBezierPoints;\nexports.chart = {};\nexports.polar = {};\nvar baseAreaMethods = {\n  _createBorderElement: chartLineSeries._createMainElement,\n  _createLegendState: function _createLegendState(styleOptions, defaultColor) {\n    return {\n      fill: styleOptions.color || defaultColor,\n      opacity: styleOptions.opacity,\n      hatching: styleOptions.hatching\n    };\n  },\n  getValueRangeInitialValue: function getValueRangeInitialValue() {\n    if (\"logarithmic\" !== this.valueAxisType && \"datetime\" !== this.valueType && false !== this.showZero) {\n      return 0;\n    } else {\n      return scatterSeries.getValueRangeInitialValue.call(this);\n    }\n  },\n  _getDefaultSegment: function _getDefaultSegment(segment) {\n    var defaultSegment = chartLineSeries._getDefaultSegment(segment);\n\n    defaultSegment.area = defaultSegment.line.concat(defaultSegment.line.slice().reverse());\n    return defaultSegment;\n  },\n  _updateElement: function _updateElement(element, segment, animate, complete) {\n    var lineParams = {\n      points: segment.line\n    };\n    var areaParams = {\n      points: segment.area\n    };\n    var borderElement = element.line;\n\n    if (animate) {\n      borderElement && borderElement.animate(lineParams);\n      element.area.animate(areaParams, {}, complete);\n    } else {\n      borderElement && borderElement.attr(lineParams);\n      element.area.attr(areaParams);\n    }\n  },\n  _removeElement: function _removeElement(element) {\n    element.line && element.line.remove();\n    element.area.remove();\n  },\n  _drawElement: function _drawElement(segment) {\n    return {\n      line: this._bordersGroup && this._createBorderElement(segment.line, {\n        \"stroke-width\": this._styles.normal.border[\"stroke-width\"]\n      }).append(this._bordersGroup),\n      area: this._createMainElement(segment.area).append(this._elementsGroup)\n    };\n  },\n  _applyStyle: function _applyStyle(style) {\n    var that = this;\n    that._elementsGroup && that._elementsGroup.smartAttr(style.elements);\n    that._bordersGroup && that._bordersGroup.attr(style.border);\n    (that._graphics || []).forEach(function (graphic) {\n      graphic.line && graphic.line.attr({\n        \"stroke-width\": style.border[\"stroke-width\"]\n      }).sharp();\n    });\n  },\n  _parseStyle: function _parseStyle(options, defaultColor, defaultBorderColor) {\n    var borderOptions = options.border || {};\n\n    var borderStyle = chartLineSeries._parseLineOptions(borderOptions, defaultBorderColor);\n\n    borderStyle.stroke = borderOptions.visible && borderStyle[\"stroke-width\"] ? borderStyle.stroke : \"none\";\n    borderStyle[\"stroke-width\"] = borderStyle[\"stroke-width\"] || 1;\n    return {\n      border: borderStyle,\n      elements: {\n        stroke: \"none\",\n        fill: options.color || defaultColor,\n        hatching: options.hatching,\n        opacity: options.opacity\n      }\n    };\n  },\n  _areBordersVisible: function _areBordersVisible() {\n    var options = this._options;\n    return options.border.visible || options.hoverStyle.border.visible || options.selectionStyle.border.visible;\n  },\n  _createMainElement: function _createMainElement(points, settings) {\n    return this._renderer.path(points, \"area\").attr(settings);\n  },\n  _getTrackerSettings: function _getTrackerSettings(segment) {\n    return {\n      \"stroke-width\": segment.singlePointSegment ? this._defaultTrackerWidth : 0\n    };\n  },\n  _getMainPointsFromSegment: function _getMainPointsFromSegment(segment) {\n    return segment.area;\n  }\n};\n\nfunction createAreaPoints(points) {\n  return _map(points, function (pt) {\n    return pt.getCoords();\n  }).concat(_map(points.slice().reverse(), function (pt) {\n    return pt.getCoords(true);\n  }));\n}\n\nvar areaSeries = exports.chart.area = _extend({}, chartLineSeries, baseAreaMethods, {\n  _prepareSegment: function _prepareSegment(points, rotated) {\n    var that = this;\n\n    var processedPoints = that._processSinglePointsAreaSegment(points, rotated);\n\n    var areaPoints = createAreaPoints(processedPoints);\n    var argAxis = that.getArgumentAxis();\n\n    if (argAxis.getAxisPosition) {\n      var argAxisPosition = argAxis.getAxisPosition();\n      var axisOptions = argAxis.getOptions();\n      var edgeOffset = (!rotated ? -1 : 1) * Math.round(axisOptions.width / 2);\n\n      if (axisOptions.visible) {\n        areaPoints.forEach(function (p, i) {\n          if (p) {\n            var index = 1 === points.length ? 0 : i < points.length ? i : areaPoints.length - 1 - i;\n            rotated && p.x === points[index].defaultX && p.x === argAxisPosition - argAxis.getAxisShift() && (p.x += edgeOffset);\n            !rotated && p.y === points[index].defaultY && p.y === argAxisPosition - argAxis.getAxisShift() && (p.y += edgeOffset);\n          }\n        });\n      }\n    }\n\n    return {\n      line: processedPoints,\n      area: areaPoints,\n      singlePointSegment: processedPoints !== points\n    };\n  },\n  _processSinglePointsAreaSegment: function _processSinglePointsAreaSegment(points, rotated) {\n    if (points && 1 === points.length) {\n      var p = points[0];\n      var p1 = objectUtils.clone(p);\n      p1[rotated ? \"y\" : \"x\"] += 1;\n      p1.argument = null;\n      return [p, p1];\n    }\n\n    return points;\n  }\n});\n\nexports.polar.area = _extend({}, polarLineSeries, baseAreaMethods, {\n  _prepareSegment: function _prepareSegment(points, rotated, lastSegment) {\n    lastSegment && polarLineSeries._closeSegment.call(this, points);\n    return areaSeries._prepareSegment.call(this, points);\n  },\n  _processSinglePointsAreaSegment: function _processSinglePointsAreaSegment(points) {\n    return lineSeries.polar.line._prepareSegment.call(this, points).line;\n  }\n});\nexports.chart.steparea = _extend({}, areaSeries, {\n  _prepareSegment: function _prepareSegment(points, rotated) {\n    var stepLineSeries = lineSeries.chart.stepline;\n    points = areaSeries._processSinglePointsAreaSegment(points, rotated);\n    return areaSeries._prepareSegment.call(this, stepLineSeries._calculateStepLinePoints.call(this, points), rotated);\n  },\n  getSeriesPairCoord: lineSeries.chart.stepline.getSeriesPairCoord\n});\nexports.chart.splinearea = _extend({}, areaSeries, {\n  _areaPointsToSplineAreaPoints: function _areaPointsToSplineAreaPoints(areaPoints) {\n    var previousMiddlePoint = areaPoints[areaPoints.length / 2 - 1];\n    var middlePoint = areaPoints[areaPoints.length / 2];\n    areaPoints.splice(areaPoints.length / 2, 0, {\n      x: previousMiddlePoint.x,\n      y: previousMiddlePoint.y\n    }, {\n      x: middlePoint.x,\n      y: middlePoint.y\n    });\n  },\n  _prepareSegment: function _prepareSegment(points, rotated) {\n    var processedPoints = areaSeries._processSinglePointsAreaSegment(points, rotated);\n\n    var areaSegment = areaSeries._prepareSegment.call(this, calculateBezierPoints(processedPoints, rotated));\n\n    this._areaPointsToSplineAreaPoints(areaSegment.area);\n\n    areaSegment.singlePointSegment = processedPoints !== points;\n    return areaSegment;\n  },\n  _getDefaultSegment: function _getDefaultSegment(segment) {\n    var areaDefaultSegment = areaSeries._getDefaultSegment(segment);\n\n    this._areaPointsToSplineAreaPoints(areaDefaultSegment.area);\n\n    return areaDefaultSegment;\n  },\n  _createMainElement: function _createMainElement(points, settings) {\n    return this._renderer.path(points, \"bezierarea\").attr(settings);\n  },\n  _createBorderElement: lineSeries.chart.spline._createMainElement,\n  getSeriesPairCoord: lineSeries.chart.spline.getSeriesPairCoord,\n  getNearestPointsByCoord: lineSeries.chart.spline.getNearestPointsByCoord,\n  obtainCubicBezierTCoef: lineSeries.chart.spline.obtainCubicBezierTCoef\n});","map":{"version":3,"sources":["C:/Users/va112/Documents/Webdev/React/Corona/node_modules/devextreme/viz/series/area_series.js"],"names":["objectUtils","require","extend","scatterSeries","chart","lineSeries","chartLineSeries","line","polarLineSeries","polar","_map","map","_extend","calculateBezierPoints","spline","_calculateBezierPoints","exports","baseAreaMethods","_createBorderElement","_createMainElement","_createLegendState","styleOptions","defaultColor","fill","color","opacity","hatching","getValueRangeInitialValue","valueAxisType","valueType","showZero","call","_getDefaultSegment","segment","defaultSegment","area","concat","slice","reverse","_updateElement","element","animate","complete","lineParams","points","areaParams","borderElement","attr","_removeElement","remove","_drawElement","_bordersGroup","_styles","normal","border","append","_elementsGroup","_applyStyle","style","that","smartAttr","elements","_graphics","forEach","graphic","sharp","_parseStyle","options","defaultBorderColor","borderOptions","borderStyle","_parseLineOptions","stroke","visible","_areBordersVisible","_options","hoverStyle","selectionStyle","settings","_renderer","path","_getTrackerSettings","singlePointSegment","_defaultTrackerWidth","_getMainPointsFromSegment","createAreaPoints","pt","getCoords","areaSeries","_prepareSegment","rotated","processedPoints","_processSinglePointsAreaSegment","areaPoints","argAxis","getArgumentAxis","getAxisPosition","argAxisPosition","axisOptions","getOptions","edgeOffset","Math","round","width","p","i","index","length","x","defaultX","getAxisShift","y","defaultY","p1","clone","argument","lastSegment","_closeSegment","steparea","stepLineSeries","stepline","_calculateStepLinePoints","getSeriesPairCoord","splinearea","_areaPointsToSplineAreaPoints","previousMiddlePoint","middlePoint","splice","areaSegment","areaDefaultSegment","getNearestPointsByCoord","obtainCubicBezierTCoef"],"mappings":"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","sourcesContent":["/**\r\n * DevExtreme (viz/series/area_series.js)\r\n * Version: 19.2.7\r\n * Build date: Thu Mar 26 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\"use strict\";\r\nvar objectUtils = require(\"../../core/utils/object\");\r\nvar extend = require(\"../../core/utils/extend\").extend;\r\nvar scatterSeries = require(\"./scatter_series\").chart;\r\nvar lineSeries = require(\"./line_series\");\r\nvar chartLineSeries = lineSeries.chart.line;\r\nvar polarLineSeries = lineSeries.polar.line;\r\nvar _map = require(\"../core/utils\").map;\r\nvar _extend = extend;\r\nvar calculateBezierPoints = lineSeries.chart.spline._calculateBezierPoints;\r\nexports.chart = {};\r\nexports.polar = {};\r\nvar baseAreaMethods = {\r\n    _createBorderElement: chartLineSeries._createMainElement,\r\n    _createLegendState: function(styleOptions, defaultColor) {\r\n        return {\r\n            fill: styleOptions.color || defaultColor,\r\n            opacity: styleOptions.opacity,\r\n            hatching: styleOptions.hatching\r\n        }\r\n    },\r\n    getValueRangeInitialValue: function() {\r\n        if (\"logarithmic\" !== this.valueAxisType && \"datetime\" !== this.valueType && false !== this.showZero) {\r\n            return 0\r\n        } else {\r\n            return scatterSeries.getValueRangeInitialValue.call(this)\r\n        }\r\n    },\r\n    _getDefaultSegment: function(segment) {\r\n        var defaultSegment = chartLineSeries._getDefaultSegment(segment);\r\n        defaultSegment.area = defaultSegment.line.concat(defaultSegment.line.slice().reverse());\r\n        return defaultSegment\r\n    },\r\n    _updateElement: function(element, segment, animate, complete) {\r\n        var lineParams = {\r\n            points: segment.line\r\n        };\r\n        var areaParams = {\r\n            points: segment.area\r\n        };\r\n        var borderElement = element.line;\r\n        if (animate) {\r\n            borderElement && borderElement.animate(lineParams);\r\n            element.area.animate(areaParams, {}, complete)\r\n        } else {\r\n            borderElement && borderElement.attr(lineParams);\r\n            element.area.attr(areaParams)\r\n        }\r\n    },\r\n    _removeElement: function(element) {\r\n        element.line && element.line.remove();\r\n        element.area.remove()\r\n    },\r\n    _drawElement: function(segment) {\r\n        return {\r\n            line: this._bordersGroup && this._createBorderElement(segment.line, {\r\n                \"stroke-width\": this._styles.normal.border[\"stroke-width\"]\r\n            }).append(this._bordersGroup),\r\n            area: this._createMainElement(segment.area).append(this._elementsGroup)\r\n        }\r\n    },\r\n    _applyStyle: function(style) {\r\n        var that = this;\r\n        that._elementsGroup && that._elementsGroup.smartAttr(style.elements);\r\n        that._bordersGroup && that._bordersGroup.attr(style.border);\r\n        (that._graphics || []).forEach(function(graphic) {\r\n            graphic.line && graphic.line.attr({\r\n                \"stroke-width\": style.border[\"stroke-width\"]\r\n            }).sharp()\r\n        })\r\n    },\r\n    _parseStyle: function(options, defaultColor, defaultBorderColor) {\r\n        var borderOptions = options.border || {};\r\n        var borderStyle = chartLineSeries._parseLineOptions(borderOptions, defaultBorderColor);\r\n        borderStyle.stroke = borderOptions.visible && borderStyle[\"stroke-width\"] ? borderStyle.stroke : \"none\";\r\n        borderStyle[\"stroke-width\"] = borderStyle[\"stroke-width\"] || 1;\r\n        return {\r\n            border: borderStyle,\r\n            elements: {\r\n                stroke: \"none\",\r\n                fill: options.color || defaultColor,\r\n                hatching: options.hatching,\r\n                opacity: options.opacity\r\n            }\r\n        }\r\n    },\r\n    _areBordersVisible: function() {\r\n        var options = this._options;\r\n        return options.border.visible || options.hoverStyle.border.visible || options.selectionStyle.border.visible\r\n    },\r\n    _createMainElement: function(points, settings) {\r\n        return this._renderer.path(points, \"area\").attr(settings)\r\n    },\r\n    _getTrackerSettings: function(segment) {\r\n        return {\r\n            \"stroke-width\": segment.singlePointSegment ? this._defaultTrackerWidth : 0\r\n        }\r\n    },\r\n    _getMainPointsFromSegment: function(segment) {\r\n        return segment.area\r\n    }\r\n};\r\n\r\nfunction createAreaPoints(points) {\r\n    return _map(points, function(pt) {\r\n        return pt.getCoords()\r\n    }).concat(_map(points.slice().reverse(), function(pt) {\r\n        return pt.getCoords(true)\r\n    }))\r\n}\r\nvar areaSeries = exports.chart.area = _extend({}, chartLineSeries, baseAreaMethods, {\r\n    _prepareSegment: function(points, rotated) {\r\n        var that = this;\r\n        var processedPoints = that._processSinglePointsAreaSegment(points, rotated);\r\n        var areaPoints = createAreaPoints(processedPoints);\r\n        var argAxis = that.getArgumentAxis();\r\n        if (argAxis.getAxisPosition) {\r\n            var argAxisPosition = argAxis.getAxisPosition();\r\n            var axisOptions = argAxis.getOptions();\r\n            var edgeOffset = (!rotated ? -1 : 1) * Math.round(axisOptions.width / 2);\r\n            if (axisOptions.visible) {\r\n                areaPoints.forEach(function(p, i) {\r\n                    if (p) {\r\n                        var index = 1 === points.length ? 0 : i < points.length ? i : areaPoints.length - 1 - i;\r\n                        rotated && p.x === points[index].defaultX && p.x === argAxisPosition - argAxis.getAxisShift() && (p.x += edgeOffset);\r\n                        !rotated && p.y === points[index].defaultY && p.y === argAxisPosition - argAxis.getAxisShift() && (p.y += edgeOffset)\r\n                    }\r\n                })\r\n            }\r\n        }\r\n        return {\r\n            line: processedPoints,\r\n            area: areaPoints,\r\n            singlePointSegment: processedPoints !== points\r\n        }\r\n    },\r\n    _processSinglePointsAreaSegment: function(points, rotated) {\r\n        if (points && 1 === points.length) {\r\n            var p = points[0];\r\n            var p1 = objectUtils.clone(p);\r\n            p1[rotated ? \"y\" : \"x\"] += 1;\r\n            p1.argument = null;\r\n            return [p, p1]\r\n        }\r\n        return points\r\n    }\r\n});\r\nexports.polar.area = _extend({}, polarLineSeries, baseAreaMethods, {\r\n    _prepareSegment: function(points, rotated, lastSegment) {\r\n        lastSegment && polarLineSeries._closeSegment.call(this, points);\r\n        return areaSeries._prepareSegment.call(this, points)\r\n    },\r\n    _processSinglePointsAreaSegment: function(points) {\r\n        return lineSeries.polar.line._prepareSegment.call(this, points).line\r\n    }\r\n});\r\nexports.chart.steparea = _extend({}, areaSeries, {\r\n    _prepareSegment: function(points, rotated) {\r\n        var stepLineSeries = lineSeries.chart.stepline;\r\n        points = areaSeries._processSinglePointsAreaSegment(points, rotated);\r\n        return areaSeries._prepareSegment.call(this, stepLineSeries._calculateStepLinePoints.call(this, points), rotated)\r\n    },\r\n    getSeriesPairCoord: lineSeries.chart.stepline.getSeriesPairCoord\r\n});\r\nexports.chart.splinearea = _extend({}, areaSeries, {\r\n    _areaPointsToSplineAreaPoints: function(areaPoints) {\r\n        var previousMiddlePoint = areaPoints[areaPoints.length / 2 - 1];\r\n        var middlePoint = areaPoints[areaPoints.length / 2];\r\n        areaPoints.splice(areaPoints.length / 2, 0, {\r\n            x: previousMiddlePoint.x,\r\n            y: previousMiddlePoint.y\r\n        }, {\r\n            x: middlePoint.x,\r\n            y: middlePoint.y\r\n        })\r\n    },\r\n    _prepareSegment: function(points, rotated) {\r\n        var processedPoints = areaSeries._processSinglePointsAreaSegment(points, rotated);\r\n        var areaSegment = areaSeries._prepareSegment.call(this, calculateBezierPoints(processedPoints, rotated));\r\n        this._areaPointsToSplineAreaPoints(areaSegment.area);\r\n        areaSegment.singlePointSegment = processedPoints !== points;\r\n        return areaSegment\r\n    },\r\n    _getDefaultSegment: function(segment) {\r\n        var areaDefaultSegment = areaSeries._getDefaultSegment(segment);\r\n        this._areaPointsToSplineAreaPoints(areaDefaultSegment.area);\r\n        return areaDefaultSegment\r\n    },\r\n    _createMainElement: function(points, settings) {\r\n        return this._renderer.path(points, \"bezierarea\").attr(settings)\r\n    },\r\n    _createBorderElement: lineSeries.chart.spline._createMainElement,\r\n    getSeriesPairCoord: lineSeries.chart.spline.getSeriesPairCoord,\r\n    getNearestPointsByCoord: lineSeries.chart.spline.getNearestPointsByCoord,\r\n    obtainCubicBezierTCoef: lineSeries.chart.spline.obtainCubicBezierTCoef\r\n});\r\n"]},"metadata":{},"sourceType":"script"}