{"ast":null,"code":"/**\r\n * DevExtreme (events/gesture/emitter.gesture.js)\r\n * Version: 19.2.7\r\n * Build date: Thu Mar 26 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar $ = require(\"../../core/renderer\");\n\nvar eventsEngine = require(\"../../events/core/events_engine\");\n\nvar devices = require(\"../../core/devices\");\n\nvar styleUtils = require(\"../../core/utils/style\");\n\nvar callOnce = require(\"../../core/utils/call_once\");\n\nvar domUtils = require(\"../../core/utils/dom\");\n\nvar readyCallbacks = require(\"../../core/utils/ready_callbacks\");\n\nvar ready = readyCallbacks.add;\n\nvar mathUtils = require(\"../../core/utils/math\");\n\nvar noop = require(\"../../core/utils/common\").noop;\n\nvar isDefined = require(\"../../core/utils/type\").isDefined;\n\nvar eventUtils = require(\"../utils\");\n\nvar Emitter = require(\"../core/emitter\");\n\nvar sign = mathUtils.sign;\nvar abs = Math.abs;\nvar SLEEP = 0;\nvar INITED = 1;\nvar STARTED = 2;\nvar TOUCH_BOUNDARY = 10;\nvar IMMEDIATE_TOUCH_BOUNDARY = 0;\nvar IMMEDIATE_TIMEOUT = 180;\n\nvar supportPointerEvents = function supportPointerEvents() {\n  return styleUtils.styleProp(\"pointer-events\");\n};\n\nvar setGestureCover = callOnce(function () {\n  var GESTURE_COVER_CLASS = \"dx-gesture-cover\";\n  var isDesktop = \"desktop\" === devices.real().deviceType;\n\n  if (!supportPointerEvents() || !isDesktop) {\n    return noop;\n  }\n\n  var $cover = $(\"<div>\").addClass(GESTURE_COVER_CLASS).css(\"pointerEvents\", \"none\");\n  eventsEngine.subscribeGlobal($cover, \"dxmousewheel\", function (e) {\n    e.preventDefault();\n  });\n  ready(function () {\n    $cover.appendTo(\"body\");\n  });\n  return function (toggle, cursor) {\n    $cover.css(\"pointerEvents\", toggle ? \"all\" : \"none\");\n    toggle && $cover.css(\"cursor\", cursor);\n  };\n});\n\nvar gestureCover = function gestureCover(toggle, cursor) {\n  var gestureCoverStrategy = setGestureCover();\n  gestureCoverStrategy(toggle, cursor);\n};\n\nvar GestureEmitter = Emitter.inherit({\n  gesture: true,\n  configure: function configure(data) {\n    this.getElement().css(\"msTouchAction\", data.immediate ? \"pinch-zoom\" : \"\");\n    this.callBase(data);\n  },\n  allowInterruptionByMouseWheel: function allowInterruptionByMouseWheel() {\n    return this._stage !== STARTED;\n  },\n  getDirection: function getDirection() {\n    return this.direction;\n  },\n  _cancel: function _cancel() {\n    this.callBase.apply(this, arguments);\n\n    this._toggleGestureCover(false);\n\n    this._stage = SLEEP;\n  },\n  start: function start(e) {\n    if (e._needSkipEvent || eventUtils.needSkipEvent(e)) {\n      this._cancel(e);\n\n      return;\n    }\n\n    this._startEvent = eventUtils.createEvent(e);\n    this._startEventData = eventUtils.eventData(e);\n    this._stage = INITED;\n\n    this._init(e);\n\n    this._setupImmediateTimer();\n  },\n  _setupImmediateTimer: function _setupImmediateTimer() {\n    clearTimeout(this._immediateTimer);\n    this._immediateAccepted = false;\n\n    if (!this.immediate) {\n      return;\n    }\n\n    this._immediateTimer = setTimeout(function () {\n      this._immediateAccepted = true;\n    }.bind(this), IMMEDIATE_TIMEOUT);\n  },\n  move: function move(e) {\n    if (this._stage === INITED && this._directionConfirmed(e)) {\n      this._stage = STARTED;\n\n      this._resetActiveElement();\n\n      this._toggleGestureCover(true);\n\n      this._clearSelection(e);\n\n      this._adjustStartEvent(e);\n\n      this._start(this._startEvent);\n\n      if (this._stage === SLEEP) {\n        return;\n      }\n\n      this._requestAccept(e);\n\n      this._move(e);\n\n      this._forgetAccept();\n    } else {\n      if (this._stage === STARTED) {\n        this._clearSelection(e);\n\n        this._move(e);\n      }\n    }\n  },\n  _directionConfirmed: function _directionConfirmed(e) {\n    var touchBoundary = this._getTouchBoundary(e);\n\n    var delta = eventUtils.eventDelta(this._startEventData, eventUtils.eventData(e));\n    var deltaX = abs(delta.x);\n    var deltaY = abs(delta.y);\n\n    var horizontalMove = this._validateMove(touchBoundary, deltaX, deltaY);\n\n    var verticalMove = this._validateMove(touchBoundary, deltaY, deltaX);\n\n    var direction = this.getDirection(e);\n    var bothAccepted = \"both\" === direction && (horizontalMove || verticalMove);\n    var horizontalAccepted = \"horizontal\" === direction && horizontalMove;\n    var verticalAccepted = \"vertical\" === direction && verticalMove;\n    return bothAccepted || horizontalAccepted || verticalAccepted || this._immediateAccepted;\n  },\n  _validateMove: function _validateMove(touchBoundary, mainAxis, crossAxis) {\n    return mainAxis && mainAxis >= touchBoundary && (this.immediate ? mainAxis >= crossAxis : true);\n  },\n  _getTouchBoundary: function _getTouchBoundary(e) {\n    return this.immediate || eventUtils.isDxMouseWheelEvent(e) ? IMMEDIATE_TOUCH_BOUNDARY : TOUCH_BOUNDARY;\n  },\n  _adjustStartEvent: function _adjustStartEvent(e) {\n    var touchBoundary = this._getTouchBoundary(e);\n\n    var delta = eventUtils.eventDelta(this._startEventData, eventUtils.eventData(e));\n    this._startEvent.pageX += sign(delta.x) * touchBoundary;\n    this._startEvent.pageY += sign(delta.y) * touchBoundary;\n  },\n  _resetActiveElement: function _resetActiveElement() {\n    if (\"ios\" === devices.real().platform && this.getElement().find(\":focus\").length) {\n      domUtils.resetActiveElement();\n    }\n  },\n  _toggleGestureCover: function _toggleGestureCover(toggle) {\n    this._toggleGestureCoverImpl(toggle);\n  },\n  _toggleGestureCoverImpl: function _toggleGestureCoverImpl(toggle) {\n    var isStarted = this._stage === STARTED;\n\n    if (isStarted) {\n      gestureCover(toggle, this.getElement().css(\"cursor\"));\n    }\n  },\n  _clearSelection: function _clearSelection(e) {\n    if (eventUtils.isDxMouseWheelEvent(e) || eventUtils.isTouchEvent(e)) {\n      return;\n    }\n\n    domUtils.clearSelection();\n  },\n  end: function end(e) {\n    this._toggleGestureCover(false);\n\n    if (this._stage === STARTED) {\n      this._end(e);\n    } else {\n      if (this._stage === INITED) {\n        this._stop(e);\n      }\n    }\n\n    this._stage = SLEEP;\n  },\n  dispose: function dispose() {\n    clearTimeout(this._immediateTimer);\n    this.callBase.apply(this, arguments);\n\n    this._toggleGestureCover(false);\n  },\n  _init: noop,\n  _start: noop,\n  _move: noop,\n  _stop: noop,\n  _end: noop\n});\nGestureEmitter.initialTouchBoundary = TOUCH_BOUNDARY;\n\nGestureEmitter.touchBoundary = function (newBoundary) {\n  if (isDefined(newBoundary)) {\n    TOUCH_BOUNDARY = newBoundary;\n    return;\n  }\n\n  return TOUCH_BOUNDARY;\n};\n\nmodule.exports = GestureEmitter;","map":{"version":3,"sources":["C:/Users/va112/Documents/Webdev/React/Corona/node_modules/devextreme/events/gesture/emitter.gesture.js"],"names":["$","require","eventsEngine","devices","styleUtils","callOnce","domUtils","readyCallbacks","ready","add","mathUtils","noop","isDefined","eventUtils","Emitter","sign","abs","Math","SLEEP","INITED","STARTED","TOUCH_BOUNDARY","IMMEDIATE_TOUCH_BOUNDARY","IMMEDIATE_TIMEOUT","supportPointerEvents","styleProp","setGestureCover","GESTURE_COVER_CLASS","isDesktop","real","deviceType","$cover","addClass","css","subscribeGlobal","e","preventDefault","appendTo","toggle","cursor","gestureCover","gestureCoverStrategy","GestureEmitter","inherit","gesture","configure","data","getElement","immediate","callBase","allowInterruptionByMouseWheel","_stage","getDirection","direction","_cancel","apply","arguments","_toggleGestureCover","start","_needSkipEvent","needSkipEvent","_startEvent","createEvent","_startEventData","eventData","_init","_setupImmediateTimer","clearTimeout","_immediateTimer","_immediateAccepted","setTimeout","bind","move","_directionConfirmed","_resetActiveElement","_clearSelection","_adjustStartEvent","_start","_requestAccept","_move","_forgetAccept","touchBoundary","_getTouchBoundary","delta","eventDelta","deltaX","x","deltaY","y","horizontalMove","_validateMove","verticalMove","bothAccepted","horizontalAccepted","verticalAccepted","mainAxis","crossAxis","isDxMouseWheelEvent","pageX","pageY","platform","find","length","resetActiveElement","_toggleGestureCoverImpl","isStarted","isTouchEvent","clearSelection","end","_end","_stop","dispose","initialTouchBoundary","newBoundary","module","exports"],"mappings":"AAAA;;;;;;;;AAQA;;AACA,IAAIA,CAAC,GAAGC,OAAO,CAAC,qBAAD,CAAf;;AACA,IAAIC,YAAY,GAAGD,OAAO,CAAC,iCAAD,CAA1B;;AACA,IAAIE,OAAO,GAAGF,OAAO,CAAC,oBAAD,CAArB;;AACA,IAAIG,UAAU,GAAGH,OAAO,CAAC,wBAAD,CAAxB;;AACA,IAAII,QAAQ,GAAGJ,OAAO,CAAC,4BAAD,CAAtB;;AACA,IAAIK,QAAQ,GAAGL,OAAO,CAAC,sBAAD,CAAtB;;AACA,IAAIM,cAAc,GAAGN,OAAO,CAAC,kCAAD,CAA5B;;AACA,IAAIO,KAAK,GAAGD,cAAc,CAACE,GAA3B;;AACA,IAAIC,SAAS,GAAGT,OAAO,CAAC,uBAAD,CAAvB;;AACA,IAAIU,IAAI,GAAGV,OAAO,CAAC,yBAAD,CAAP,CAAmCU,IAA9C;;AACA,IAAIC,SAAS,GAAGX,OAAO,CAAC,uBAAD,CAAP,CAAiCW,SAAjD;;AACA,IAAIC,UAAU,GAAGZ,OAAO,CAAC,UAAD,CAAxB;;AACA,IAAIa,OAAO,GAAGb,OAAO,CAAC,iBAAD,CAArB;;AACA,IAAIc,IAAI,GAAGL,SAAS,CAACK,IAArB;AACA,IAAIC,GAAG,GAAGC,IAAI,CAACD,GAAf;AACA,IAAIE,KAAK,GAAG,CAAZ;AACA,IAAIC,MAAM,GAAG,CAAb;AACA,IAAIC,OAAO,GAAG,CAAd;AACA,IAAIC,cAAc,GAAG,EAArB;AACA,IAAIC,wBAAwB,GAAG,CAA/B;AACA,IAAIC,iBAAiB,GAAG,GAAxB;;AACA,IAAIC,oBAAoB,GAAG,SAAvBA,oBAAuB,GAAW;AAClC,SAAOpB,UAAU,CAACqB,SAAX,CAAqB,gBAArB,CAAP;AACH,CAFD;;AAGA,IAAIC,eAAe,GAAGrB,QAAQ,CAAC,YAAW;AACtC,MAAIsB,mBAAmB,GAAG,kBAA1B;AACA,MAAIC,SAAS,GAAG,cAAczB,OAAO,CAAC0B,IAAR,GAAeC,UAA7C;;AACA,MAAI,CAACN,oBAAoB,EAArB,IAA2B,CAACI,SAAhC,EAA2C;AACvC,WAAOjB,IAAP;AACH;;AACD,MAAIoB,MAAM,GAAG/B,CAAC,CAAC,OAAD,CAAD,CAAWgC,QAAX,CAAoBL,mBAApB,EAAyCM,GAAzC,CAA6C,eAA7C,EAA8D,MAA9D,CAAb;AACA/B,EAAAA,YAAY,CAACgC,eAAb,CAA6BH,MAA7B,EAAqC,cAArC,EAAqD,UAASI,CAAT,EAAY;AAC7DA,IAAAA,CAAC,CAACC,cAAF;AACH,GAFD;AAGA5B,EAAAA,KAAK,CAAC,YAAW;AACbuB,IAAAA,MAAM,CAACM,QAAP,CAAgB,MAAhB;AACH,GAFI,CAAL;AAGA,SAAO,UAASC,MAAT,EAAiBC,MAAjB,EAAyB;AAC5BR,IAAAA,MAAM,CAACE,GAAP,CAAW,eAAX,EAA4BK,MAAM,GAAG,KAAH,GAAW,MAA7C;AACAA,IAAAA,MAAM,IAAIP,MAAM,CAACE,GAAP,CAAW,QAAX,EAAqBM,MAArB,CAAV;AACH,GAHD;AAIH,CAjB6B,CAA9B;;AAkBA,IAAIC,YAAY,GAAG,SAAfA,YAAe,CAASF,MAAT,EAAiBC,MAAjB,EAAyB;AACxC,MAAIE,oBAAoB,GAAGf,eAAe,EAA1C;AACAe,EAAAA,oBAAoB,CAACH,MAAD,EAASC,MAAT,CAApB;AACH,CAHD;;AAIA,IAAIG,cAAc,GAAG5B,OAAO,CAAC6B,OAAR,CAAgB;AACjCC,EAAAA,OAAO,EAAE,IADwB;AAEjCC,EAAAA,SAAS,EAAE,mBAASC,IAAT,EAAe;AACtB,SAAKC,UAAL,GAAkBd,GAAlB,CAAsB,eAAtB,EAAuCa,IAAI,CAACE,SAAL,GAAiB,YAAjB,GAAgC,EAAvE;AACA,SAAKC,QAAL,CAAcH,IAAd;AACH,GALgC;AAMjCI,EAAAA,6BAA6B,EAAE,yCAAW;AACtC,WAAO,KAAKC,MAAL,KAAgB/B,OAAvB;AACH,GARgC;AASjCgC,EAAAA,YAAY,EAAE,wBAAW;AACrB,WAAO,KAAKC,SAAZ;AACH,GAXgC;AAYjCC,EAAAA,OAAO,EAAE,mBAAW;AAChB,SAAKL,QAAL,CAAcM,KAAd,CAAoB,IAApB,EAA0BC,SAA1B;;AACA,SAAKC,mBAAL,CAAyB,KAAzB;;AACA,SAAKN,MAAL,GAAcjC,KAAd;AACH,GAhBgC;AAiBjCwC,EAAAA,KAAK,EAAE,eAASvB,CAAT,EAAY;AACf,QAAIA,CAAC,CAACwB,cAAF,IAAoB9C,UAAU,CAAC+C,aAAX,CAAyBzB,CAAzB,CAAxB,EAAqD;AACjD,WAAKmB,OAAL,CAAanB,CAAb;;AACA;AACH;;AACD,SAAK0B,WAAL,GAAmBhD,UAAU,CAACiD,WAAX,CAAuB3B,CAAvB,CAAnB;AACA,SAAK4B,eAAL,GAAuBlD,UAAU,CAACmD,SAAX,CAAqB7B,CAArB,CAAvB;AACA,SAAKgB,MAAL,GAAchC,MAAd;;AACA,SAAK8C,KAAL,CAAW9B,CAAX;;AACA,SAAK+B,oBAAL;AACH,GA3BgC;AA4BjCA,EAAAA,oBAAoB,EAAE,gCAAW;AAC7BC,IAAAA,YAAY,CAAC,KAAKC,eAAN,CAAZ;AACA,SAAKC,kBAAL,GAA0B,KAA1B;;AACA,QAAI,CAAC,KAAKrB,SAAV,EAAqB;AACjB;AACH;;AACD,SAAKoB,eAAL,GAAuBE,UAAU,CAAC,YAAW;AACzC,WAAKD,kBAAL,GAA0B,IAA1B;AACH,KAFiC,CAEhCE,IAFgC,CAE3B,IAF2B,CAAD,EAEnBhD,iBAFmB,CAAjC;AAGH,GArCgC;AAsCjCiD,EAAAA,IAAI,EAAE,cAASrC,CAAT,EAAY;AACd,QAAI,KAAKgB,MAAL,KAAgBhC,MAAhB,IAA0B,KAAKsD,mBAAL,CAAyBtC,CAAzB,CAA9B,EAA2D;AACvD,WAAKgB,MAAL,GAAc/B,OAAd;;AACA,WAAKsD,mBAAL;;AACA,WAAKjB,mBAAL,CAAyB,IAAzB;;AACA,WAAKkB,eAAL,CAAqBxC,CAArB;;AACA,WAAKyC,iBAAL,CAAuBzC,CAAvB;;AACA,WAAK0C,MAAL,CAAY,KAAKhB,WAAjB;;AACA,UAAI,KAAKV,MAAL,KAAgBjC,KAApB,EAA2B;AACvB;AACH;;AACD,WAAK4D,cAAL,CAAoB3C,CAApB;;AACA,WAAK4C,KAAL,CAAW5C,CAAX;;AACA,WAAK6C,aAAL;AACH,KAbD,MAaO;AACH,UAAI,KAAK7B,MAAL,KAAgB/B,OAApB,EAA6B;AACzB,aAAKuD,eAAL,CAAqBxC,CAArB;;AACA,aAAK4C,KAAL,CAAW5C,CAAX;AACH;AACJ;AACJ,GA1DgC;AA2DjCsC,EAAAA,mBAAmB,EAAE,6BAAStC,CAAT,EAAY;AAC7B,QAAI8C,aAAa,GAAG,KAAKC,iBAAL,CAAuB/C,CAAvB,CAApB;;AACA,QAAIgD,KAAK,GAAGtE,UAAU,CAACuE,UAAX,CAAsB,KAAKrB,eAA3B,EAA4ClD,UAAU,CAACmD,SAAX,CAAqB7B,CAArB,CAA5C,CAAZ;AACA,QAAIkD,MAAM,GAAGrE,GAAG,CAACmE,KAAK,CAACG,CAAP,CAAhB;AACA,QAAIC,MAAM,GAAGvE,GAAG,CAACmE,KAAK,CAACK,CAAP,CAAhB;;AACA,QAAIC,cAAc,GAAG,KAAKC,aAAL,CAAmBT,aAAnB,EAAkCI,MAAlC,EAA0CE,MAA1C,CAArB;;AACA,QAAII,YAAY,GAAG,KAAKD,aAAL,CAAmBT,aAAnB,EAAkCM,MAAlC,EAA0CF,MAA1C,CAAnB;;AACA,QAAIhC,SAAS,GAAG,KAAKD,YAAL,CAAkBjB,CAAlB,CAAhB;AACA,QAAIyD,YAAY,GAAG,WAAWvC,SAAX,KAAyBoC,cAAc,IAAIE,YAA3C,CAAnB;AACA,QAAIE,kBAAkB,GAAG,iBAAiBxC,SAAjB,IAA8BoC,cAAvD;AACA,QAAIK,gBAAgB,GAAG,eAAezC,SAAf,IAA4BsC,YAAnD;AACA,WAAOC,YAAY,IAAIC,kBAAhB,IAAsCC,gBAAtC,IAA0D,KAAKzB,kBAAtE;AACH,GAvEgC;AAwEjCqB,EAAAA,aAAa,EAAE,uBAAST,aAAT,EAAwBc,QAAxB,EAAkCC,SAAlC,EAA6C;AACxD,WAAOD,QAAQ,IAAIA,QAAQ,IAAId,aAAxB,KAA0C,KAAKjC,SAAL,GAAiB+C,QAAQ,IAAIC,SAA7B,GAAyC,IAAnF,CAAP;AACH,GA1EgC;AA2EjCd,EAAAA,iBAAiB,EAAE,2BAAS/C,CAAT,EAAY;AAC3B,WAAO,KAAKa,SAAL,IAAkBnC,UAAU,CAACoF,mBAAX,CAA+B9D,CAA/B,CAAlB,GAAsDb,wBAAtD,GAAiFD,cAAxF;AACH,GA7EgC;AA8EjCuD,EAAAA,iBAAiB,EAAE,2BAASzC,CAAT,EAAY;AAC3B,QAAI8C,aAAa,GAAG,KAAKC,iBAAL,CAAuB/C,CAAvB,CAApB;;AACA,QAAIgD,KAAK,GAAGtE,UAAU,CAACuE,UAAX,CAAsB,KAAKrB,eAA3B,EAA4ClD,UAAU,CAACmD,SAAX,CAAqB7B,CAArB,CAA5C,CAAZ;AACA,SAAK0B,WAAL,CAAiBqC,KAAjB,IAA0BnF,IAAI,CAACoE,KAAK,CAACG,CAAP,CAAJ,GAAgBL,aAA1C;AACA,SAAKpB,WAAL,CAAiBsC,KAAjB,IAA0BpF,IAAI,CAACoE,KAAK,CAACK,CAAP,CAAJ,GAAgBP,aAA1C;AACH,GAnFgC;AAoFjCP,EAAAA,mBAAmB,EAAE,+BAAW;AAC5B,QAAI,UAAUvE,OAAO,CAAC0B,IAAR,GAAeuE,QAAzB,IAAqC,KAAKrD,UAAL,GAAkBsD,IAAlB,CAAuB,QAAvB,EAAiCC,MAA1E,EAAkF;AAC9EhG,MAAAA,QAAQ,CAACiG,kBAAT;AACH;AACJ,GAxFgC;AAyFjC9C,EAAAA,mBAAmB,EAAE,6BAASnB,MAAT,EAAiB;AAClC,SAAKkE,uBAAL,CAA6BlE,MAA7B;AACH,GA3FgC;AA4FjCkE,EAAAA,uBAAuB,EAAE,iCAASlE,MAAT,EAAiB;AACtC,QAAImE,SAAS,GAAG,KAAKtD,MAAL,KAAgB/B,OAAhC;;AACA,QAAIqF,SAAJ,EAAe;AACXjE,MAAAA,YAAY,CAACF,MAAD,EAAS,KAAKS,UAAL,GAAkBd,GAAlB,CAAsB,QAAtB,CAAT,CAAZ;AACH;AACJ,GAjGgC;AAkGjC0C,EAAAA,eAAe,EAAE,yBAASxC,CAAT,EAAY;AACzB,QAAItB,UAAU,CAACoF,mBAAX,CAA+B9D,CAA/B,KAAqCtB,UAAU,CAAC6F,YAAX,CAAwBvE,CAAxB,CAAzC,EAAqE;AACjE;AACH;;AACD7B,IAAAA,QAAQ,CAACqG,cAAT;AACH,GAvGgC;AAwGjCC,EAAAA,GAAG,EAAE,aAASzE,CAAT,EAAY;AACb,SAAKsB,mBAAL,CAAyB,KAAzB;;AACA,QAAI,KAAKN,MAAL,KAAgB/B,OAApB,EAA6B;AACzB,WAAKyF,IAAL,CAAU1E,CAAV;AACH,KAFD,MAEO;AACH,UAAI,KAAKgB,MAAL,KAAgBhC,MAApB,EAA4B;AACxB,aAAK2F,KAAL,CAAW3E,CAAX;AACH;AACJ;;AACD,SAAKgB,MAAL,GAAcjC,KAAd;AACH,GAlHgC;AAmHjC6F,EAAAA,OAAO,EAAE,mBAAW;AAChB5C,IAAAA,YAAY,CAAC,KAAKC,eAAN,CAAZ;AACA,SAAKnB,QAAL,CAAcM,KAAd,CAAoB,IAApB,EAA0BC,SAA1B;;AACA,SAAKC,mBAAL,CAAyB,KAAzB;AACH,GAvHgC;AAwHjCQ,EAAAA,KAAK,EAAEtD,IAxH0B;AAyHjCkE,EAAAA,MAAM,EAAElE,IAzHyB;AA0HjCoE,EAAAA,KAAK,EAAEpE,IA1H0B;AA2HjCmG,EAAAA,KAAK,EAAEnG,IA3H0B;AA4HjCkG,EAAAA,IAAI,EAAElG;AA5H2B,CAAhB,CAArB;AA8HA+B,cAAc,CAACsE,oBAAf,GAAsC3F,cAAtC;;AACAqB,cAAc,CAACuC,aAAf,GAA+B,UAASgC,WAAT,EAAsB;AACjD,MAAIrG,SAAS,CAACqG,WAAD,CAAb,EAA4B;AACxB5F,IAAAA,cAAc,GAAG4F,WAAjB;AACA;AACH;;AACD,SAAO5F,cAAP;AACH,CAND;;AAOA6F,MAAM,CAACC,OAAP,GAAiBzE,cAAjB","sourcesContent":["/**\r\n * DevExtreme (events/gesture/emitter.gesture.js)\r\n * Version: 19.2.7\r\n * Build date: Thu Mar 26 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\"use strict\";\r\nvar $ = require(\"../../core/renderer\");\r\nvar eventsEngine = require(\"../../events/core/events_engine\");\r\nvar devices = require(\"../../core/devices\");\r\nvar styleUtils = require(\"../../core/utils/style\");\r\nvar callOnce = require(\"../../core/utils/call_once\");\r\nvar domUtils = require(\"../../core/utils/dom\");\r\nvar readyCallbacks = require(\"../../core/utils/ready_callbacks\");\r\nvar ready = readyCallbacks.add;\r\nvar mathUtils = require(\"../../core/utils/math\");\r\nvar noop = require(\"../../core/utils/common\").noop;\r\nvar isDefined = require(\"../../core/utils/type\").isDefined;\r\nvar eventUtils = require(\"../utils\");\r\nvar Emitter = require(\"../core/emitter\");\r\nvar sign = mathUtils.sign;\r\nvar abs = Math.abs;\r\nvar SLEEP = 0;\r\nvar INITED = 1;\r\nvar STARTED = 2;\r\nvar TOUCH_BOUNDARY = 10;\r\nvar IMMEDIATE_TOUCH_BOUNDARY = 0;\r\nvar IMMEDIATE_TIMEOUT = 180;\r\nvar supportPointerEvents = function() {\r\n    return styleUtils.styleProp(\"pointer-events\")\r\n};\r\nvar setGestureCover = callOnce(function() {\r\n    var GESTURE_COVER_CLASS = \"dx-gesture-cover\";\r\n    var isDesktop = \"desktop\" === devices.real().deviceType;\r\n    if (!supportPointerEvents() || !isDesktop) {\r\n        return noop\r\n    }\r\n    var $cover = $(\"<div>\").addClass(GESTURE_COVER_CLASS).css(\"pointerEvents\", \"none\");\r\n    eventsEngine.subscribeGlobal($cover, \"dxmousewheel\", function(e) {\r\n        e.preventDefault()\r\n    });\r\n    ready(function() {\r\n        $cover.appendTo(\"body\")\r\n    });\r\n    return function(toggle, cursor) {\r\n        $cover.css(\"pointerEvents\", toggle ? \"all\" : \"none\");\r\n        toggle && $cover.css(\"cursor\", cursor)\r\n    }\r\n});\r\nvar gestureCover = function(toggle, cursor) {\r\n    var gestureCoverStrategy = setGestureCover();\r\n    gestureCoverStrategy(toggle, cursor)\r\n};\r\nvar GestureEmitter = Emitter.inherit({\r\n    gesture: true,\r\n    configure: function(data) {\r\n        this.getElement().css(\"msTouchAction\", data.immediate ? \"pinch-zoom\" : \"\");\r\n        this.callBase(data)\r\n    },\r\n    allowInterruptionByMouseWheel: function() {\r\n        return this._stage !== STARTED\r\n    },\r\n    getDirection: function() {\r\n        return this.direction\r\n    },\r\n    _cancel: function() {\r\n        this.callBase.apply(this, arguments);\r\n        this._toggleGestureCover(false);\r\n        this._stage = SLEEP\r\n    },\r\n    start: function(e) {\r\n        if (e._needSkipEvent || eventUtils.needSkipEvent(e)) {\r\n            this._cancel(e);\r\n            return\r\n        }\r\n        this._startEvent = eventUtils.createEvent(e);\r\n        this._startEventData = eventUtils.eventData(e);\r\n        this._stage = INITED;\r\n        this._init(e);\r\n        this._setupImmediateTimer()\r\n    },\r\n    _setupImmediateTimer: function() {\r\n        clearTimeout(this._immediateTimer);\r\n        this._immediateAccepted = false;\r\n        if (!this.immediate) {\r\n            return\r\n        }\r\n        this._immediateTimer = setTimeout(function() {\r\n            this._immediateAccepted = true\r\n        }.bind(this), IMMEDIATE_TIMEOUT)\r\n    },\r\n    move: function(e) {\r\n        if (this._stage === INITED && this._directionConfirmed(e)) {\r\n            this._stage = STARTED;\r\n            this._resetActiveElement();\r\n            this._toggleGestureCover(true);\r\n            this._clearSelection(e);\r\n            this._adjustStartEvent(e);\r\n            this._start(this._startEvent);\r\n            if (this._stage === SLEEP) {\r\n                return\r\n            }\r\n            this._requestAccept(e);\r\n            this._move(e);\r\n            this._forgetAccept()\r\n        } else {\r\n            if (this._stage === STARTED) {\r\n                this._clearSelection(e);\r\n                this._move(e)\r\n            }\r\n        }\r\n    },\r\n    _directionConfirmed: function(e) {\r\n        var touchBoundary = this._getTouchBoundary(e);\r\n        var delta = eventUtils.eventDelta(this._startEventData, eventUtils.eventData(e));\r\n        var deltaX = abs(delta.x);\r\n        var deltaY = abs(delta.y);\r\n        var horizontalMove = this._validateMove(touchBoundary, deltaX, deltaY);\r\n        var verticalMove = this._validateMove(touchBoundary, deltaY, deltaX);\r\n        var direction = this.getDirection(e);\r\n        var bothAccepted = \"both\" === direction && (horizontalMove || verticalMove);\r\n        var horizontalAccepted = \"horizontal\" === direction && horizontalMove;\r\n        var verticalAccepted = \"vertical\" === direction && verticalMove;\r\n        return bothAccepted || horizontalAccepted || verticalAccepted || this._immediateAccepted\r\n    },\r\n    _validateMove: function(touchBoundary, mainAxis, crossAxis) {\r\n        return mainAxis && mainAxis >= touchBoundary && (this.immediate ? mainAxis >= crossAxis : true)\r\n    },\r\n    _getTouchBoundary: function(e) {\r\n        return this.immediate || eventUtils.isDxMouseWheelEvent(e) ? IMMEDIATE_TOUCH_BOUNDARY : TOUCH_BOUNDARY\r\n    },\r\n    _adjustStartEvent: function(e) {\r\n        var touchBoundary = this._getTouchBoundary(e);\r\n        var delta = eventUtils.eventDelta(this._startEventData, eventUtils.eventData(e));\r\n        this._startEvent.pageX += sign(delta.x) * touchBoundary;\r\n        this._startEvent.pageY += sign(delta.y) * touchBoundary\r\n    },\r\n    _resetActiveElement: function() {\r\n        if (\"ios\" === devices.real().platform && this.getElement().find(\":focus\").length) {\r\n            domUtils.resetActiveElement()\r\n        }\r\n    },\r\n    _toggleGestureCover: function(toggle) {\r\n        this._toggleGestureCoverImpl(toggle)\r\n    },\r\n    _toggleGestureCoverImpl: function(toggle) {\r\n        var isStarted = this._stage === STARTED;\r\n        if (isStarted) {\r\n            gestureCover(toggle, this.getElement().css(\"cursor\"))\r\n        }\r\n    },\r\n    _clearSelection: function(e) {\r\n        if (eventUtils.isDxMouseWheelEvent(e) || eventUtils.isTouchEvent(e)) {\r\n            return\r\n        }\r\n        domUtils.clearSelection()\r\n    },\r\n    end: function(e) {\r\n        this._toggleGestureCover(false);\r\n        if (this._stage === STARTED) {\r\n            this._end(e)\r\n        } else {\r\n            if (this._stage === INITED) {\r\n                this._stop(e)\r\n            }\r\n        }\r\n        this._stage = SLEEP\r\n    },\r\n    dispose: function() {\r\n        clearTimeout(this._immediateTimer);\r\n        this.callBase.apply(this, arguments);\r\n        this._toggleGestureCover(false)\r\n    },\r\n    _init: noop,\r\n    _start: noop,\r\n    _move: noop,\r\n    _stop: noop,\r\n    _end: noop\r\n});\r\nGestureEmitter.initialTouchBoundary = TOUCH_BOUNDARY;\r\nGestureEmitter.touchBoundary = function(newBoundary) {\r\n    if (isDefined(newBoundary)) {\r\n        TOUCH_BOUNDARY = newBoundary;\r\n        return\r\n    }\r\n    return TOUCH_BOUNDARY\r\n};\r\nmodule.exports = GestureEmitter;\r\n"]},"metadata":{},"sourceType":"script"}